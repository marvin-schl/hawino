<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="AStar" Id="{7641bcc2-8598-421f-b509-a825c115c758}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK AStar
VAR_INPUT
	enable : BOOL := FALSE;
	xRobotActual, yRobotActual : LREAL;
	xEnd, yEnd : LREAL;
	endNode : INT ;
END_VAR
VAR_OUTPUT
	finishedASearch : BOOL := FALSE;
	xCoordinates, yCoordinates : ARRAY[0..100] OF LREAL;
END_VAR
VAR
	numberOfNodes : INT := 144;
	a, b, c, d, e, i, j, k, m, o, p, q, t, v, w, counter, number, cnt1, cnt2, cntPark : INT;
	numberOfColumns : INT := 18;
	matrix : ARRAY[1..170,1..170] OF LREAL;
	row, col : LREAL;
	xNode, yNode : ARRAY[1..170] OF LREAL;
	removeNode : ARRAY[0..15] OF INT := [36, 54, 72, 90, 93, 96, 99, 102, 111, 114, 117, 120, 124, 125, 142, 143];
	startNode : INT := 0; //fragwürdig
	diff_x, diff_y, diff_total : ARRAY[1..170] OF LREAL;
	min_total : LREAL;
	openList : ARRAY[1..170,1..6] OF LREAL;
	nullOpenList : ARRAY[1..170,1..6] OF LREAL := [1020(0)];
	closedList : ARRAY[1..170] OF LREAL;
	h, f, gprev : LREAL;
	g : LREAL := 0;
	parentNode : INT ;
	countNeighbor, indexMin, currentNode : INT;
	neighborList:ARRAY[1..8,1..5] OF LREAL;
	nullMatrix_Neighbor : ARRAY[1..8,1..5] OF LREAL := [40(0)];
	nullMatrix_TempArray : ARRAY[1..170,1..7] OF LREAL := [1190(0)];
	flag : BOOL;
	countOpen : INT := 1;
	tempArray : ARRAY[1..170,1..7] OF LREAL;
	countTemp : INT := 1;
	minf : LREAL;
	wayPointList : ARRAY[1..101] OF INT;
	wayPointList_finished : ARRAY[0..100] OF INT;
	countClosed : INT := 1;
	countPointList : INT := 1;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[reset();
openList := nullOpenList;

///////////////////////////////////////////Erstellen der Adjezenzmatrix//////////////////////////////////////////////////////////////////
FOR i := 0 TO numberOfNodes BY 1 DO
	 IF i-1 > 0 AND i MOD numberOfColumns <> 1 THEN									//linker Nachbar
		 matrix[i-1,i] := 1000;
	 END_IF
	 IF i+1 < numberOfNodes+1 AND i MOD numberOfColumns <> 0 THEN					//rechter Nachbar
		 matrix[i+1,i] := 1000;
	 END_IF
	 IF i+numberOfColumns < numberOfNodes+1 THEN									//oberer Nachbar
		 matrix[i+numberOfColumns,i] := 1000;
	 END_IF
	 IF i-numberOfColumns > 0 THEN													//unterer Nachbar
		 matrix[i-numberOfColumns,i] := 1000;
	 END_IF
	 IF i+numberOfColumns+1 < numberOfNodes+1 AND i MOD numberOfColumns <> 0 THEN	//Nachbar oben rechts
		 matrix[i+numberOfColumns+1,i] := SQRT(2)*1000;
	 END_IF
	 IF i+numberOfColumns-1 < numberOfNodes+1 AND i MOD numberOfColumns <> 1 THEN	//Nachbar oben links
		 matrix[i+numberOfColumns-1,i] := SQRT(2)*1000;
	 END_IF
	 IF i-numberOfColumns+1 > 0 AND i MOD numberOfColumns <> 0 THEN					//Nachbar unten rechts
		 matrix[i-numberOfColumns+1,i] := SQRT(2)*1000;
	 END_IF
	 IF i-numberOfColumns-1 > 0 AND i MOD numberOfColumns <> 1 THEN					//Nachbar unten links
		 matrix[i-numberOfColumns-1,i] := SQRT(2)*1000;
	 END_IF
 END_FOR
 
//Löschen der Knoten über Station und die nahegelegenen diagonalen Verbindungen
 FOR counter := 0 TO 15 BY 1 DO
	FOR j := 1 TO 170 BY 1 DO
		matrix[removeNode[counter],j] := 0;
		matrix[j, removeNode[counter]] := 0;
 	END_FOR
	
	//diagonale Verbindung oben links
	IF removeNode[counter] - 1 > 0 AND removeNode[counter] + numberOfColumns <= numberOfNodes THEN 
		matrix[removeNode[counter] - 1, removeNode[counter] + numberOfColumns] := 0;	
		matrix[removeNode[counter] + numberOfColumns, removeNode[counter] - 1] := 0;	
	END_IF
	
	//diagonale Verbindung unten links
	IF removeNode[counter] - 1 > 0 AND removeNode[counter] - numberOfColumns > 0 THEN 
		matrix[removeNode[counter] - 1, removeNode[counter] - numberOfColumns] := 0;	
		matrix[removeNode[counter] - numberOfColumns, removeNode[counter] - 1] := 0;	
	END_IF
	
	//diagonale Verbindung oben rechts
	IF removeNode[counter] + 1 <= numberOfNodes AND removeNode[counter] + numberOfColumns <= numberOfNodes THEN 
		matrix[removeNode[counter] + 1, removeNode[counter] + numberOfColumns] := 0;	
		matrix[removeNode[counter] + numberOfColumns, removeNode[counter] + 1] := 0;	
	END_IF
	
	//diagonale Verbindung unten rechts
	IF removeNode[counter] + 1 <= numberOfNodes AND removeNode[counter] - numberOfColumns > 0 THEN
		matrix[removeNode[counter] + 1, removeNode[counter] - numberOfColumns] := 0;	
		matrix[removeNode[counter] - numberOfColumns, removeNode[counter] + 1] := 0;	
	END_IF
	
	//alle entfernten Knoten auf unrealistische Koordinaten setzen, damit sie nicht als Startknoten in Frage kommen, außer die Partplätze
	IF counter > 3 THEN
		xNode[removeNode[counter]] := 10000;
		yNode[removeNode[counter]] := 10000;
	END_IF
 END_FOR
 
 //neues Raster für Taschenanfahrt
 o := 0;
 FOR number := 1 TO 24 BY 6 DO
	 FOR cnt1 := 0 TO 2 BY 1 DO 
		 matrix[numberOfNodes + number + cnt1, 92 + o] := 1000;
		 matrix[92 + o, numberOfNodes + number + cnt1] := 1000;
		 matrix[numberOfNodes + number + cnt1, 110 + o] := 1000;
		 matrix[110 + o, numberOfNodes + number + cnt1] := 1000;
	END_FOR
	FOR cnt2 := 3 TO 5 BY 1 DO 
		 matrix[numberOfNodes + number + cnt2, 92 + o + 2] := 1000;
		 matrix[92 + o + 2, numberOfNodes + number + cnt2] := 1000;
		 matrix[numberOfNodes + number + cnt2, 110 + o + 2] := 1000;
		 matrix[110 + o + 2, numberOfNodes + number + cnt2] := 1000;
	END_FOR
	o := o + 3;
 END_FOR
 
 matrix[numberOfNodes + number, 106] := 1000;
 matrix[106, numberOfNodes + number] := 1000;
 matrix[numberOfNodes + number + 1, 107] := 1000;
 matrix[107, numberOfNodes + number + 1] := 1000;
 
 //Parkplätze mit nur einer Verbindung
 FOR cntPark := 36 TO 91 BY 18 DO
	 matrix[cntPark, cntPark-1] := 1000;
	 matrix[cntPark-1, cntPark] := 1000;
 END_FOR
 
 //Umrechnung von Knoten in Koordinaten
 row := 600;
 col := 200;
 
  FOR i := 1 TO numberOfNodes BY 1 DO
	 IF xNode[i] <> 10000 THEN
	 	xNode[i] := col;
	 END_IF
	 IF yNode[i] <> 10000 THEN
	 	yNode[i] := row;
	 END_IF
	 col := col + 400;
	 IF i MOD numberOfColumns = 0 THEN
		 col := 200;
		 row := row + 400;
	 END_IF
 END_FOR
 
 //nochmal mit pickuplocation und co machen also ohne magic numbers
 xNode[145] := 790;
 xNode[146] := 790;
 xNode[147] := 790;
 xNode[148] := 1410;
 xNode[149] := 1410;
 xNode[150] := 1410;
 xNode[151] := 1990;
 xNode[152] := 1990;
 xNode[153] := 1990;
 xNode[154] := 2550;
 xNode[155] := 2550;
 xNode[156] := 2550;
 xNode[157] := 3130;
 xNode[158] := 3130;
 xNode[159] := 3130;
 xNode[160] := 3760;
 xNode[161] := 3760;
 xNode[162] := 3760;
 xNode[163] := 4360;
 xNode[164] := 4360;
 xNode[165] := 4360;
 xNode[166] := 5000;
 xNode[167] := 5000;
 xNode[168] := 5000;
 xNode[169] := 6117;
 xNode[170] := 6716;
 
 yNode[145] := 2735;
 yNode[146] := 2838;
 yNode[147] := 2936;
 yNode[148] := 2736;
 yNode[149] := 2835;
 yNode[150] := 2935;
 yNode[151] := 2731;
 yNode[152] := 2829;
 yNode[153] := 2931;
 yNode[154] := 2732;
 yNode[155] := 2833;
 yNode[156] := 2928;
 yNode[157] := 2732;
 yNode[158] := 2837;
 yNode[159] := 2940;
 yNode[160] := 2732;
 yNode[161] := 2840;
 yNode[162] := 2940;
 yNode[163] := 2732;
 yNode[164] := 2838;
 yNode[165] := 2944;
 yNode[166] := 2737;
 yNode[167] := 2855;
 yNode[168] := 2942;
 yNode[169] := 3100;
 yNode[170] := 3100;
 
 //Knoten für bessere Anfahrt versetzen, damit nicht zu dicht an Station
 //xNode[94] := 1500;
 //xNode[103] := 5100;
 //xNode[112] := 1500;
 //xNode[121] := 5100;
 
 ////////////////////////////////////////////////////Startposition und Endposition bestimmen //////////////////////////////////////////////////////////////////////////
 
 FOR i := 1 TO 170 BY 1 DO
	 diff_x[i] := ABS(xRobotActual - xNode[i]);
	 diff_y[i] := ABS(yRobotActual - yNode[i]);
	 diff_total[i] := diff_x[i] + diff_y[i];
 END_FOR
 
 min_total := 1000000;
 
 FOR m := 1 TO 170 BY 1 DO
	 IF min_total >= diff_total[m] THEN
		 min_total := diff_total[m];
		 startNode := m;
	 END_IF
 END_FOR
 
 /////////////////////////////////////////////////////AStern Algorithmus////////////////////////////////////////////////////////////////////////////////
 currentNode := startNode;
 h := SQRT(EXPT(xNode[startNode]-xEnd,2) + EXPT(yNode[startNode]-yEnd,2));
 f := g + h;
 
 //übergibt hier zu entfernende Nodes in closed List -> nötig?
 
 //insert start node in openList
 openList[1,1] := 1;
 openList[1,2] := startNode;
 openList[1,3] := g;
 openList[1,4] := h;
 openList[1,5] := f;
 openList[1,6] := parentNode;
 
 //put in closedList
 closedList[1] := startNode;
 openList[1,1] := 0;
 
 //Goal reached?
 WHILE currentNode <> endNode DO
	 //clear neighborlist
 	countNeighbor := 1;
	neighborList := nullMatrix_Neighbor;
	
	//search the neightbor and put in neighborlist
	gprev := g;																		//ausversehen gelöscht??? geht jetzt?
	FOR v := 1 TO 170 BY 1 DO
		//calculate forwards
		IF matrix[currentNode,v] <> 0 THEN
			g := gprev + SQRT(EXPT(xNode[v]-xNode[currentNode],2) + EXPT(yNode[v]-yNode[currentNode],2));
			h := SQRT(EXPT(xNode[v]-xEnd,2) + EXPT(yNode[v]-yEnd,2));
			neighborList[countNeighbor,1] := v;
			neighborList[countNeighbor,2] := g;
			neighborList[countNeighbor,3] := h;
			neighborList[countNeighbor,4] := g + h;
			neighborList[countNeighbor,5] := currentNode;
			countNeighbor := countNeighbor + 1;
		END_IF
	END_FOR
	
	//possible neighbors will be inserted in openList
	FOR w := 1 TO 8 BY 1 DO
		flag := 0;
		FOR a := 1 TO 170 BY 1 DO
			//if already exist, update g, h, g and parent
			IF neighborList[w,1] = openList[a,2] THEN
				openList[a,5] := MIN(openList[a,5], neighborList[w,4]);
				IF openList[a,5] = neighborList[w,4] THEN
					openList[a,3] := neighborList[w,2];
					openList[a,4] := neighborList[w,3];
					openList[a,6] := neighborList[w,5];
				END_IF
				flag := 1;
			END_IF
		END_FOR
		IF flag = 0 AND neighborList[w,1] <> 0 THEN
			countOpen := countOpen +1;
			openList[countOpen,1] := 1;
			openList[countOpen,2] := neighborList[w,1]; //node
			openList[countOpen,3] := neighborList[w,2]; //g
			openList[countOpen,4] := neighborList[w,3]; //h
			openList[countOpen,5] := neighborList[w,4]; //f
			openList[countOpen,6] := neighborList[w,5]; //parent
		END_IF
	END_FOR
	 
	//find out the node with the smallest fn
	countTemp := 1;
	tempArray := nullMatrix_TempArray;
	FOR b := 1 TO countOpen BY 1 DO
		IF openList[b,1] = 1 THEN
			tempArray[countTemp, 1] := openList[b, 1];
			tempArray[countTemp, 2] := openList[b, 2];
			tempArray[countTemp, 3] := openList[b, 3];
			tempArray[countTemp, 4] := openList[b, 4];
			tempArray[countTemp, 5] := openList[b, 5];
			tempArray[countTemp, 6] := openList[b, 6];
			tempArray[countTemp, 7] := b;
			countTemp := countTemp + 1;
		END_IF
	END_FOR
	FOR d := 1 TO 170 BY 1 DO
		IF tempArray[d,5] = 0 THEN
			tempArray[d,5] := 10000000;
		END_IF
	END_FOR
	
	minf := 100000;
	
	FOR e := 1 TO 170 BY 1 DO
		IF tempArray[e,5] < minf THEN
			minf := tempArray[e,5];
			indexMin := LREAL_TO_INT(tempArray[e,7]);
		END_IF
	END_FOR
	
	//found smallest fn, update openList and put in closedList
	openList[indexMin, 1] := 0;
	currentNode := LREAL_TO_INT(openList[indexMin, 2]);
	gprev := openList[indexMin,3];
	countClosed := countClosed + 1;
	closedList[countClosed] := currentNode;
 END_WHILE
 
 //Optimal path is generated by starting of the goal node to start node
 FOR k := countClosed TO 1 BY -1 DO
	 IF currentNode <> startNode THEN
		 wayPointList[countPointList] := currentNode;
		 FOR p := 1 TO countOpen BY 1 DO
			 IF openList[p,2] = currentNode THEN
				 currentNode := LREAL_TO_INT(openList[p,6]);
			 END_IF
		 END_FOR
		 countPointList := countPointList + 1;
	 ELSE
		wayPointList[countPointList] := currentNode;
		EXIT;
	 END_IF
 END_FOR

 FOR c := countPointList TO 1 BY -1 DO
	 wayPointList_finished[q] := wayPointList[c];
	 q := q + 1;
 END_FOR
 
 //////////////////////////////////////////////////Liste in Koordinaten/////////////////////////////////////////////////
 
//WayPointList in Koordinaten umwandeln
FOR t := 0 TO 100 BY 1 DO
	IF wayPointList_finished[t] <> 0 THEN
		xCoordinates[t] := xNode[wayPointList_finished[t]];
		yCoordinates[t] := yNode[wayPointList_finished[t]];
	END_IF
END_FOR
 
 
 finishedASearch := TRUE;]]></ST>
    </Implementation>
    <Method Name="reset" Id="{1844f933-5385-4c4f-b16b-9087fe62c4bc}">
      <Declaration><![CDATA[METHOD reset : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[Zeros_INT(wayPointList_finished);
Zeros(closedList);
zeros_INT(wayPointList);
zeros(xCoordinates);
zeros(yCoordinates);
//Matrix?
zeros(xNode);
zeros(yNode);
//removeNode?
zeros(diff_x);
zeros(diff_y);

finishedASearch := FALSE;
numberOfNodes := 144;
q := 0;
numberOfColumns := 18;
parentNode := 0;
g := 0;
flag := FALSE;
countOpen := 1;
countTemp := 1;
countClosed := 1;
countPointList := 1;
]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="AStar">
      <LineId Id="1084" Count="0" />
      <LineId Id="1130" Count="0" />
      <LineId Id="773" Count="27" />
      <LineId Id="803" Count="0" />
      <LineId Id="1193" Count="5" />
      <LineId Id="1228" Count="0" />
      <LineId Id="1199" Count="0" />
      <LineId Id="1218" Count="1" />
      <LineId Id="1201" Count="1" />
      <LineId Id="1220" Count="0" />
      <LineId Id="1203" Count="0" />
      <LineId Id="1221" Count="0" />
      <LineId Id="1204" Count="2" />
      <LineId Id="1222" Count="0" />
      <LineId Id="1207" Count="0" />
      <LineId Id="1223" Count="0" />
      <LineId Id="1208" Count="2" />
      <LineId Id="1224" Count="0" />
      <LineId Id="1211" Count="0" />
      <LineId Id="1226" Count="0" />
      <LineId Id="1212" Count="2" />
      <LineId Id="1546" Count="1" />
      <LineId Id="1227" Count="0" />
      <LineId Id="1215" Count="1" />
      <LineId Id="1545" Count="0" />
      <LineId Id="810" Count="1" />
      <LineId Id="1253" Count="0" />
      <LineId Id="1231" Count="0" />
      <LineId Id="1233" Count="18" />
      <LineId Id="1229" Count="1" />
      <LineId Id="1454" Count="1" />
      <LineId Id="1457" Count="0" />
      <LineId Id="1459" Count="0" />
      <LineId Id="1458" Count="0" />
      <LineId Id="1456" Count="0" />
      <LineId Id="812" Count="3" />
      <LineId Id="1022" Count="11" />
      <LineId Id="824" Count="0" />
      <LineId Id="1255" Count="0" />
      <LineId Id="1310" Count="0" />
      <LineId Id="1257" Count="52" />
      <LineId Id="1256" Count="0" />
      <LineId Id="1407" Count="4" />
      <LineId Id="825" Count="5" />
      <LineId Id="1355" Count="0" />
      <LineId Id="831" Count="1" />
      <LineId Id="1357" Count="0" />
      <LineId Id="1364" Count="0" />
      <LineId Id="1358" Count="4" />
      <LineId Id="1356" Count="0" />
      <LineId Id="867" Count="2" />
      <LineId Id="872" Count="2" />
      <LineId Id="876" Count="20" />
      <LineId Id="1502" Count="0" />
      <LineId Id="898" Count="72" />
      <LineId Id="1217" Count="0" />
      <LineId Id="971" Count="18" />
      <LineId Id="1002" Count="16" />
      <LineId Id="67" Count="0" />
    </LineIds>
    <LineIds Name="AStar.reset">
      <LineId Id="5" Count="4" />
      <LineId Id="20" Count="5" />
      <LineId Id="14" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="15" Count="1" />
      <LineId Id="19" Count="0" />
      <LineId Id="28" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="33" Count="1" />
      <LineId Id="32" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>