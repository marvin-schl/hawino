<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="Kollisionserkennung" Id="{2163055e-1523-4ae1-8ad2-f781f29a50e9}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM Kollisionserkennung
VAR
	robotPoseArray AT%I*: ARRAY[1..8] OF RobotPose;
	robotPoseLokal : ARRAY[1..8] OF RobotPose;
	vxRobot AT%I*: LREAL;
	vyRobot AT%I*: LREAL;
	collisionDetected : BOOL := FALSE;
	robotCollision AT%Q* : ARRAY[0..4] OF BOOL;
		
	xRobot, yRobot: LREAL;
	i, j, k, l, m, n, o : INT := 1;
	quadrant, counter : INT := 0;
	noCamera, cameraDown, permanentDown, stateCameraDown  : BOOL := FALSE;
	
	//Bounding Box
	x1Box,y1Box,x2Box,y2Box,x3Box,y3Box,x4Box,y4Box : LREAL; 
	alpha, beta, gamma, diagonal : LREAL := 0.0;
	breite, laenge : INT;
	
	//Timer
	timer :TON;
	timeValue : TIME := T#2S;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[ ////////Main function/////////
timer(IN:= noCamera, PT := timeValue); //Roboter darf 2s blind fahren

//suche die Position des passenden Roboters
FOR i := 1 TO 4 BY 1 DO
	IF i = Var_HAWIno.Robot_Number THEN
		xRobot := robotPoseArray[i].x;
		yRobot := robotPoseArray[i].y;
	END_IF
END_FOR

//350mm Durchmesser des Roboters & 130mm Toleranzabstand
breite := 350 + 80; 
laenge := 350 + 80;
diagonal := SQRT(EXPT(breite,2) + EXPT(laenge,2));
IF vyRobot <> 0 AND vxRobot <> 0 THEN
	gamma  := ATAN2(vyRobot,vxRobot); //Drehung des Roboters
END_IF
beta := ATAN(laenge/breite); //Winkel des festen Dreiecks

//Kameradaten verfügbar 
IF xRobot <> 0 AND yRobot <> 0 THEN
	noCamera := FALSE;
	cameraDown := FALSE;
	
	//Zurücksetzen wenn Kameradaten wieder da
	IF stateCameraDown = TRUE THEN
		stateCameraDown := FALSE;
		FOR n:= 0 TO 4 BY 1 DO
			robotCollision[n] := FALSE;
		END_FOR
	END_IF
	
	//Zwischenspeicher der letzten Positionen lokal wenn die Kameradaten nicht ausfallen
	IF robotPoseArray[1].x <> 0 AND robotPoseArray[1].y <> 0 THEN
		robotPoseLokal[1].x := robotPoseArray[1].x;
		robotPoseLokal[1].y := robotPoseArray[1].y;
	END_IF
	IF robotPoseArray[2].x <> 0 AND robotPoseArray[2].y <> 0 THEN
		robotPoseLokal[2].x := robotPoseArray[2].x;
		robotPoseLokal[2].y := robotPoseArray[2].y;
	END_IF
	IF robotPoseArray[3].x <> 0 AND robotPoseArray[3].y <> 0 THEN
		robotPoseLokal[3].x := robotPoseArray[3].x;
		robotPoseLokal[3].y := robotPoseArray[3].y;
	END_IF
	IF robotPoseArray[4].x <> 0 AND robotPoseArray[4].y <> 0 THEN
		robotPoseLokal[4].x := robotPoseArray[4].x;
		robotPoseLokal[4].y := robotPoseArray[4].y;
	END_IF
	
//Kameradaten ausfallen	
ELSE
	noCamera := TRUE;
	cameraDown := TRUE;
	//Kameradaten länger als 2s ausfallen, setzt die Array auf true
	IF timer.Q THEN
		permanentDown := TRUE;
	ELSE
		permanentDown := FALSE;
	END_IF
END_IF

//Kameradaten ausfallen, dann die lokale Position wird zugegriffen
IF cameraDown = TRUE AND permanentDown = FALSE THEN
	xRobot := robotPoseLokal[Var_HAWIno.Robot_Number].x;
	yRobot := robotPoseLokal[Var_HAWIno.Robot_Number].y;
	
//Kameradaten 2s lang ausfallen, ist die gesamte Array robotCollision True und RobotPoseArray = 0
ELSIF cameraDown = TRUE AND permanentDown = TRUE THEN
	xRobot := 0.0;
	yRobot := 0.0;
	FOR o:= 0 TO 4 BY 1 DO
		IF o = 0 THEN
			robotCollision[o] := TRUE;
		ELSE 
			robotCollision[o] := TRUE;
			robotPoseArray[o].x := 0.0;
			robotPoseArray[o].y := 0.0;
			robotPoseArray[o].theta := 0.0;
			robotPoseArray[o].e := 0.0;
		END_IF
	END_FOR
	stateCameraDown := TRUE;
END_IF

//Bounding Box dreht mit der Roboterblickrichtung
IF gamma >= 0 AND gamma < pi/2 THEN //Quadrant 1
	quadrant := 1;
	alpha := pi/2 - gamma; //Winkel des gedrehten Boxes
	x1Box := xRobot + COS(alpha) * breite;
	y1Box := yRobot - SIN(alpha) * breite;
	x2Box := xRobot + SIN(alpha + beta) * diagonal;
	y2Box := yRobot + COS(alpha + beta) * diagonal;
	x3Box := xRobot - COS(alpha + beta) * diagonal;
	y3Box := yRobot + SIN(alpha + beta) * diagonal;
	x4Box := xRobot - COS(alpha) * breite;
	y4Box := yRobot + SIN(alpha) * breite;	
ELSIF gamma >= pi/2 AND gamma <= pi THEN //Quadrant 2
	quadrant := 2;
	alpha := pi - gamma;
	x1Box := xRobot + SIN(alpha) * breite;
	y1Box := yRobot + COS(alpha) * breite;
	x2Box := xRobot - COS(alpha + beta) * diagonal;
	y2Box := yRobot + SIN(alpha + beta) * diagonal;
	x3Box := xRobot - SIN(alpha + beta) * diagonal;
	y3Box := yRobot - COS(alpha + beta) * diagonal;
	x4Box := xRobot - SIN(alpha) * breite;
	y4Box := yRobot - COS(alpha) * breite;
ELSIF gamma > -pi AND gamma < -pi/2 THEN //Quadrant 3
	quadrant := 3;
	alpha := pi + gamma;
	x1Box := xRobot - SIN(alpha) * breite;
	y1Box := yRobot + COS(alpha) * breite;
	x2Box := xRobot - SIN(alpha + beta) * diagonal;
	y2Box := yRobot + COS(alpha + beta) * diagonal;
	x3Box := xRobot - COS(alpha + beta) * diagonal;
	y3Box := yRobot - SIN(alpha + beta) * diagonal;
	x4Box := xRobot + SIN(alpha) * breite;
	y4Box := yRobot - COS(alpha) * breite;	
ELSIF gamma >= -pi/2 AND gamma < 0 THEN //Quadrant 4
	quadrant := 4;
	alpha := gamma + pi/2;
	x1Box := xRobot - COS(alpha) * breite;
	y1Box := yRobot - SIN(alpha) * breite;
	x2Box := xRobot - COS(alpha + beta) * diagonal;
	y2Box := yRobot - SIN(alpha + beta) * diagonal;
	x3Box := xRobot + SIN(alpha + beta) * diagonal;
	y3Box := yRobot - COS(alpha + beta) * diagonal;
	x4Box := xRobot + COS(alpha) * breite;
	y4Box := yRobot + SIN(alpha) * breite;
END_IF

//Erkennt Roboter Kollision in Box?
FOR k := 1 TO 4 BY 1 DO
	IF k <> Var_HAWIno.Robot_Number THEN
		IF quadrant = 1 THEN
			IF robotPoseLokal[k].x < x2Box AND robotPoseLokal[k].x > x4Box AND robotPoseLokal[k].y < y3Box AND robotPoseLokal[k].y > y1Box THEN
				collisionDetected := TRUE;
			ELSE
				collisionDetected := FALSE;
			END_IF
		ELSIF quadrant = 2 THEN
			IF robotPoseLokal[k].x < x1Box AND robotPoseLokal[k].x > x3Box AND robotPoseLokal[k].y < y2Box AND robotPoseLokal[k].y > y4Box THEN
				collisionDetected := TRUE;
			ELSE
				collisionDetected := FALSE;
			END_IF
		ELSIF quadrant = 3 THEN
			IF robotPoseLokal[k].x < x4Box AND robotPoseLokal[k].x > x2Box AND robotPoseLokal[k].y < y1Box AND robotPoseLokal[k].y > y3Box THEN
				collisionDetected := TRUE;
			ELSE
				collisionDetected := FALSE;
			END_IF
		ELSIF quadrant = 4 THEN
			IF robotPoseLokal[k].x < x3Box AND robotPoseLokal[k].x > x1Box AND robotPoseLokal[k].y < y4Box AND robotPoseLokal[k].y > y2Box THEN
				collisionDetected := TRUE;
			ELSE
				collisionDetected := FALSE;
			END_IF
		END_IF
	END_IF
	
	//Kollision erkannt und die beteiligten Robotern werden True gesetzt
	IF collisionDetected = TRUE THEN
		robotCollision[k] := TRUE;
		robotCollision[Var_HAWIno.Robot_Number] := TRUE; 
	ELSIF collisionDetected = FALSE AND k <> Var_HAWIno.Robot_Number THEN
		robotCollision[k] := FALSE;
	END_IF
END_FOR 

//Keine Roboter kollidieren sich, setzt der Roboter zurück
counter := 0;
FOR l := 1 TO 4 BY 1 DO
	IF robotCollision[l] = FALSE THEN
		counter := counter + 1;
	END_IF
END_FOR
IF counter = 3 THEN
	robotCollision[Var_HAWIno.Robot_Number] := FALSE;
END_IF]]></ST>
    </Implementation>
    <LineIds Name="Kollisionserkennung">
      <LineId Id="756" Count="32" />
      <LineId Id="954" Count="15" />
      <LineId Id="795" Count="17" />
      <LineId Id="818" Count="105" />
      <LineId Id="970" Count="0" />
      <LineId Id="924" Count="2" />
      <LineId Id="930" Count="0" />
      <LineId Id="927" Count="2" />
      <LineId Id="409" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>