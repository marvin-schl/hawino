<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="Fahrauftrag" Id="{d11e2ac1-1df3-4b17-bdc0-8c45421bbbdd}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM Fahrauftrag
VAR
	//State machine
	sStart : BOOL := TRUE;
	s0,s1a,s1b,s2,s3,s4,s5,s6a,s6b,s7,s8,s9,s10,s11a,s11b,s12,s13,s14,s15,s16,s17,s18,s19,s20,s21a,s21b,s22,s23,s24,s25,s25b,s26a,s26b,s27,s28,s29,s30,s31,s32,s33,s34,s35: BOOL := FALSE;
	sk0, sk1, sk2, sk3, sk4, sk10, sk20, sk21, sk22, sk23, sk24, sk25, sk26, sk27, sk28, sk29, sk30, sk31, sk32, sk33 : BOOL := FALSE; //States von Kollision
	
	AStar : AStar;										//A-Stern Algorithmus
	readAssigment: ReadAssigment;						//Auswertung des Auftrags
	TrajectoryController: TrajectoryControl;			//Schnittstelle zu GW3
	
	wayPointList : ARRAY[0..100] OF RobotPoseSimple;	//Wegpunktliste
	actualCamX, actualCamY : LREAL;						//letzte Kameradaten ungleich 0
	lastRelevantStateForCollision : STRING(5);			//letzter State für Rückfall bei Kollision
	
	//Schnittstelle zum MQTT_PRG
	FeedbackToGW1 AT%Q*: STRING(50);		//Feedback/Status des Roboters an GW1
	resetVarMQTT, resetGoBack AT%Q*: BOOL;					//messages von MQTT zurücksetzen
	RoboNmbToGoBack AT%Q* : ARRAY[0..4] OF INT;
	Auftrag AT%I*: Auftrag;					//Auftrag von GW1
	StatusFromGW1 AT%I*: STRING(50);		//Status von GW1
	goBack AT%I* : BOOL;					//zurückfahren auf Befehl von anderem HAWino
	reset AT%I* : BOOL;						//Fahrauftrag und GW3 zurücksetzen auf Befehl von GW1
	
	//Schnittstelle zu A*-Algorithmus
	EndNode : INT;							//letzter Knoten
	xEndvalue : LREAL;						//Ziel xKoordinate
	xRobotStartposition : LREAL;			//aktuelle xKoordinate
	yEndvalue : LREAL;						//Ziel yKoordinate
	yRobotStartposition : LREAL;			//aktuelle yKoordinate
	xPointList : ARRAY[0..100] OF LREAL;	//xKoordinatenliste
	yPointList : ARRAY[0..100] OF LREAL;	//yKoordinatenliste
	finished_ASearch : BOOL;	 			//Variable, dass Algorithmus fertig
	i: INT;									//Laufvariable zum Übertragen der x und y Koordinaten in die Wegpunktliste
	zeile: INT;								//Arrayindex, wo Wegpunktliste zuende
	
	//Kollision
	collision AT%I*: ARRAY[0..4] OF BOOL;		//Collision wurde erkannt
	lastCollision: ARRAY [0..4] OF BOOL;		//letzte Collision gespeichert
	collisionFree, collisionSolutionWorking : BOOL;				//keine Kollision aktuell
	removeNodeCollision : ARRAY[1..11] OF INT;	//Nodes die durch anderen HAWino blockiert
	todo : STRING(10);							//Aufgabe von diesem HAWino bei Kollision (fahren oder warten)
	firstTime: BOOL := TRUE;	
	timerCollision : TON;						//Zeit die bei Kollision gewartet wird, bevor Reaktion folgt
	otherRobo : ARRAY[0..4] OF INT;				//andere HAWinos, die an Kollision beteilgit
	otherRoboAtStation, otherRoboAtStop, thisRoboAtStation, drivingAtStation, newCollision, sameStation : BOOL;			//anderer beteiligter HAWino ist im Stationsbereich
	
	//Greifer
	closeGripperCommand AT%Q* : BOOL;
	
	//error
	noCamera, error : BOOL;
	resetTimer : TON;
	failedCounter: INT;
	cameraX, cameraY : ARRAY[1..4] OF LREAL;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[timerCollision();
resetTimer();
errorTest();
CameraDataSaved();

collisionFree := NOT collision[Var_HAWIno.Robot_Number];

IF lastCollision[1] <> collision[1] OR lastCollision[2] <> collision[2] OR lastCollision[3] <> collision[3] OR lastCollision[4] <> collision[4] OR collision[0] THEN
	IF collision[Var_HAWIno.Robot_Number] THEN
		newCollision := TRUE;
	END_IF
	lastCollision := collision;
END_IF

//IF collision[0] THEN
	//TrajectoryController.xBoEnable := FALSE;
	//FeedbackToGW1 := 'Kameraausfall';
IF collision[Var_HAWIno.Robot_Number] AND newCollision AND NOT collisionSolutionWorking THEN
	TrajectoryController.xBoEnable := FALSE;
	sk0 := TRUE;
	CollisionsSolution_new();
	newCollision := FALSE;
	timerCollision.IN := TRUE;
	timerCollision.PT := T#2S;
ELSIF collisionSolutionWorking THEN
	CollisionsSolution_new();
END_IF

//Camera damit immer Daten da
IF camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].x <> 0 AND camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].y <> 0 THEN
	actualCamX := camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].x;
	actualCamY := camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].y;
END_IF

////////////////////////////////////////////////////////StateMaschine/////////////////////////////////////////////////

//Init
IF sStart AND NOT s0 THEN
	lastRelevantStateForCollision := 's0';
	sStart := 0; s0 := 1;
	//	RückmeldungGW1 Verfügbar
	FeedbackToGW1 := 'Verfuegbar';
	resetVarMQTT := FALSE;
	TrajectoryController.xBoReset := FALSE;
END_IF

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////FAHRAUFTRAG/////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

//	Warten auf Auftrag
IF s0 AND NOT s1a AND Auftrag.Art = 'Fahrauftrag' THEN
	s0 := 0; s1a := 1;
	lastRelevantStateForCollision := 's1a';
	//	RückmeldugGW1 Auftrag angenommen setzt
	FeedbackToGW1 := 'Auftrag angenommen';
	//Auftrag auswerten
	readAssigment(assigment:= Auftrag);
	EndNode := readAssigment.endNodePickup;															
	xEndvalue := readAssigment.pickupLocation.x;
	yEndvalue := readAssigment.pickupLocation.y;
	xRobotStartposition := camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].x;
	yRobotStartposition := camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].y;	
END_IF

IF s1a AND NOT s1b AND xRobotStartposition <> 0 AND yRobotStartposition <> 0 THEN
	AStar(xRobotActual := xRobotStartposition, yRobotActual := yRobotStartposition, xEnd := xEndvalue, yEnd := yEndvalue, endNode := EndNode, blockedNodes := removeNodeCollision);
	finished_ASearch := AStar.finishedASearch;
	IF finished_ASearch THEN
		xPointList := AStar.xCoordinates;
		yPointList := AStar.yCoordinates;
		s1a := 0; s1b := 1;
	END_IF
ELSIF s1a AND NOT s1b THEN
	xRobotStartposition := actualCamX;
	yRobotStartposition := actualCamY;
END_IF

//Bahnplanung
IF s1b AND NOT s2 AND finished_ASearch THEN
	ZEROS_RobotPoseSimple(wayPointList);
	ZEROS_INT(removeNodeCollision);
	finished_ASearch := FALSE;
	FOR i := 0 TO 100 BY 1 DO
 		wayPointList[i] := ToRobotPoseSimple(x:= xPointList[i], y:= yPointList[i], theta:= -1);
		IF xPointList[i] = 0 THEN
			zeile := i;
			EXIT;
		END_IF
	END_FOR
	wayPointList[zeile] := readAssigment.pickupLocation;
	wayPointList[zeile+1] := ToRobotPoseSimple(x := -1, y := -1, theta := -1);
	TrajectoryController.setWaypointList(waypointList);
	trajectoryController.newWaypointListAvailable := TRUE;
	s1b := 0; s2 := 1;
END_IF

///////////////////////////////////////////////FahrtZumAbholort///////////////////////////////////////////////////

// 	RückmeldungGW3 Wegpunkte erhalten abwarten
IF s2 AND NOT s3 AND trajectoryController.yControllerState = ControllerState.setTrajectory THEN
	s2 := 0; s3 := 1;
	trajectoryController.newWaypointListAvailable := FALSE;
END_IF

// 	RückmeldungGW3 ready abwarten
IF s3 AND NOT s4 AND trajectoryController.yControllerState = ControllerState.ready THEN
	s3 := 0; s4 := 1;
	trajectoryController.xBoEnable := TRUE;
END_IF
	
//	RückmeldungGW3 Fahrt abwarten
IF s4 AND NOT s5 AND trajectoryController.yControllerState = ControllerState.driving THEN
	s4 := 0; s5 := 1;
	//	RückmeldungGW1 Auf Anfahrt setzen
	FeedbackToGW1 := 'Auf Anfahrt';
END_IF

//	RückmeldungGW3 am Ziel abwarten
IF s5 AND NOT s6a AND trajectoryController.yBoArrivedAtDestination THEN
	lastRelevantStateForCollision := 's6a';
	trajectoryController.xBoEnable := FALSE;
	//	Greifersteuerung
	IF NOT Gripper.partGripped THEN
		closeGripperCommand := TRUE;
		s5 := 0; s6a := 1;
	END_IF
END_IF
												
IF s6a AND NOT s6b AND NOT Gripper.partGripped THEN
	s6a := 0; s6b := 1;	
	lastRelevantStateForCollision := 's6b';
	//	RückmeldungGW1 Teil aufgenommen setzen
	FeedbackToGW1 := 'Teil aufgenommen';
	//	Fahrauftrag zu Lesekopf
	ZEROS_RobotPoseSimple(wayPointList);
	wayPointList := readAssigment.pointsFromSlotToReader;
	TrajectoryController.setWaypointList(wayPointList);
	trajectoryController.newWaypointListAvailable := TRUE;
//ELSIF s6a AND NOT s6b AND Gripper.partGripped THEN
	//Gripper.closeGripperCommand := FALSE;
	//ZEROS_RobotPoseSimple(wayPointList);
	//IF auftrag.AbholTasche = 1 OR auftrag.AbholTasche = 2 THEN
	//	wayPointList[0] := ToRobotPoseSimple(x := readAssigment.pickupLocation.x - 100, y := readAssigment.pickupLocation.y, theta := readAssigment.pickupLocation.theta);
	//ELSIF auftrag.AbholTasche = 3 OR auftrag.AbholTasche = 4 THEN
	//	wayPointList[0] := ToRobotPoseSimple(x := readAssigment.pickupLocation.x + 100, y := readAssigment.pickupLocation.y, theta := readAssigment.pickupLocation.theta);
	//END_IF
	//wayPointList[1] := readAssigment.pickupLocation;
	//wayPointList[2] := ToRobotPoseSimple(x := -1, y := -1, theta := -1);
	//TrajectoryController.setWaypointList(waypointList);
	//trajectoryController.newWaypointListAvailable := TRUE;
	//s6a := 0; s2 := 1;
END_IF


/////////////////////////////////////////////////////FahrtZumLesekopf/////////////////////////////////////////////////////////

// 	RückmeldungGW3 Wegpunkte erhalten abwarten
IF s6b AND NOT s7 AND trajectoryController.yControllerState = ControllerState.setTrajectory AND gripper.state = CoreGripperControlState.Open THEN
	s6b := 0; s7 := 1;
	trajectoryController.newWaypointListAvailable := FALSE;
END_IF

// 	RückmeldungGW3 ready abwarten
IF s7 AND NOT s8 AND trajectoryController.yControllerState = ControllerState.ready THEN
	s7 := 0; s8 := 1;
	trajectoryController.xBoEnable := TRUE;
END_IF
	
//	RückmeldungGW3 Fahrt abwarten
IF s8 AND NOT s9 AND trajectoryController.yControllerState = ControllerState.driving THEN
	s8 := 0; s9 := 1;
	resetVarMQTT := TRUE;
END_IF

//	RückmeldungGW3 am Ziel abwarten
IF s9 AND NOT s10 AND trajectoryController.yBoArrivedAtDestination THEN
	s9 := 0; s10 := 1;
	lastRelevantStateForCollision := 's10';
	trajectoryController.xBoEnable := FALSE;
	resetVarMQTT := FALSE;
	//	RückmeldungGW1 Abmeldung
	FeedbackToGW1 := 'Abmeldung';
END_IF

//	Warten auf Werkstück ausgelesen
IF s10 AND NOT s11a AND StatusFromGW1 = 'WerkstueckAusgelesen' THEN
	s10 := 0; s11a := 1;
	lastRelevantStateForCollision := 's11a';
	//resetVarMQTT := TRUE;
	
	//Auftrag auswerten
	EndNode   := readAssigment.endNodeStorage;																	
	xEndvalue := readAssigment.storageLocation.x;
	yEndvalue := readAssigment.storageLocation.y;
	yRobotStartposition := camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].y;	
	xRobotStartposition := camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].x;
	//IF readAssigment.assigment.AbholTasche < 3 THEN
	//	xRobotStartposition := camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].x - 200;
	//ELSE
	//	xRobotStartposition := camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].x + 200;
	//END_IF
END_IF

IF s11a AND NOT s11b AND xRobotStartposition <> 0 AND yRobotStartposition <> 0 THEN
	AStar(xRobotActual := xRobotStartposition, yRobotActual := yRobotStartposition, xEnd := xEndvalue, yEnd := yEndvalue, endNode := EndNode, blockedNodes := removeNodeCollision);
	finished_ASearch := AStar.finishedASearch;
	IF finished_ASearch THEN
		xPointList := AStar.xCoordinates;
		yPointList := AStar.yCoordinates;
		s11a := 0; s11b := 1;
	END_IF
	//resetVarMQTT := FALSE;
ELSIF s11a AND NOT s11b THEN
	//IF readAssigment.assigment.AbholTasche < 3 THEN	
	//	xRobotStartposition := actualCamX - 200;
	//ELSE
	//	xRobotStartposition := actualCamX + 200;
	//END_IF
	xRobotStartposition := actualCamX;
	yRobotStartposition := actualCamY;
END_IF

//Bahnplanung
IF s11b AND NOT s12 AND finished_ASearch THEN
	ZEROS_RobotPoseSimple(wayPointList);
	ZEROS_INT(removeNodeCollision);
	finished_ASearch := FALSE;
	FOR i := 0 TO 100 BY 1 DO
 		wayPointList[i] := ToRobotPoseSimple(x:= xPointList[i], y:= yPointList[i], theta:= -1);
		IF xPointList[i] = 0 THEN
			zeile := i;
			EXIT;
		END_IF
	END_FOR
	wayPointList[zeile] := readAssigment.readerCheckIn;
	wayPointList[zeile+1] := ToRobotPoseSimple(x := -1, y := -1, theta := -1);
	TrajectoryController.setWaypointList(waypointList);
	trajectoryController.newWaypointListAvailable := TRUE;
	s11b := 0; s12 := 1;
END_IF

/////////////////////////////////////////////////FahrtZurAblageStation///////////////////////////////////////////////////

// 	RückmeldungGW3 Wegpunkte erhalten abwarten
IF s12 AND NOT s13 AND trajectoryController.yControllerState = ControllerState.setTrajectory THEN
	s12 := 0; s13 := 1;
	trajectoryController.newWaypointListAvailable := FALSE;
END_IF

// 	RückmeldungGW3 ready abwarten
IF s13 AND NOT s14 AND trajectoryController.yControllerState = ControllerState.ready THEN
	s13 := 0; s14 := 1;
	trajectoryController.xBoEnable := TRUE;
END_IF
	
//	RückmeldungGW3 Fahrt abwarten
IF s14 AND NOT s15 AND trajectoryController.yControllerState = ControllerState.driving THEN
	s14 := 0; s15 := 1;
	resetVarMQTT := TRUE;
	//resetVar := FALSE;
	//	RückmeldungGW1 Auf Anfahrt setzen
	FeedbackToGW1 := 'Auf Transport';
END_IF

//	RückmeldungGW3 am Ziel abwarten
IF s15 AND NOT s16 AND trajectoryController.yBoArrivedAtDestination THEN
	s15 := 0; s16 := 1;
	lastRelevantStateForCollision := 's16';	
	trajectoryController.xBoEnable := FALSE;
	resetVarMQTT := FALSE;
	//	RückmeldungGW1 Anmeldung
	FeedbackToGW1 := 'Anmeldung';
END_IF

//	Warten auf Werkstück ausgelesen
IF s16 AND NOT s17 AND StatusFromGW1 = 'WerkstueckAusgelesen' THEN
	s16 := 0; s17 := 1;
	lastRelevantStateForCollision := 's17';
	//resetVarMQTT := TRUE;
	//	Fahrauftrag zur Ablage
	ZEROS_RobotPoseSimple(wayPointList);
	wayPointList := readAssigment.pointsFromReaderToSlot;
	TrajectoryController.setWaypointList(wayPointList);
	trajectoryController.newWaypointListAvailable := TRUE;
END_IF

//////////////////////////////////////////////////FahrtZurAblage///////////////////////////////////////////////////////

// 	RückmeldungGW3 Wegpunkte erhalten abwarten
IF s17 AND NOT s18 AND trajectoryController.yControllerState = ControllerState.setTrajectory THEN
	s17 := 0; s18 := 1;
	trajectoryController.newWaypointListAvailable := FALSE;
END_IF

// 	RückmeldungGW3 ready abwarten
IF s18 AND NOT s19 AND trajectoryController.yControllerState = ControllerState.ready THEN
	s18 := 0; s19 := 1;
	trajectoryController.xBoEnable := TRUE;
	//resetVarMQTT := FALSE;
END_IF
	
//	RückmeldungGW3 Fahrt abwarten
IF s19 AND NOT s20 AND trajectoryController.yControllerState = ControllerState.driving THEN
	s19 := 0; s20 := 1;
	resetVarMQTT := TRUE;
	//resetVar := FALSE;
END_IF

//	RückmeldungGW3 am Ziel abwarten
IF s20 AND NOT s21a AND trajectoryController.yBoArrivedAtDestination THEN
	s20 := 0; s21a := 1;
	resetVarMQTT := FALSE;
	lastRelevantStateForCollision := 's21a';
	trajectoryController.xBoEnable := FALSE;
	//	Greifersteuerung
	closeGripperCommand := FALSE;
	//	RückmeldungGW1 Teil abgelegt
	FeedbackToGW1 := 'Teil abgelegt';
	//	Fahrauftrag zum Parkplatz
	EndNode := readAssigment.endNodeParking[Var_HAWIno.Robot_Number];															//todo in matlab
	xEndvalue := readAssigment.parkingSlots[Var_HAWIno.Robot_Number].x;
	yEndvalue := readAssigment.parkingSlots[Var_HAWIno.Robot_Number].y;
	//IF readAssigment.assigment.AblageTasche < 3 THEN
	//	xRobotStartposition := camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].x - 200;
	//ELSE
	//	xRobotStartposition := camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].x + 200;
	//END_IF
	xRobotStartposition := camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].x;
	yRobotStartposition := camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].y;	
END_IF

				
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////LADEAUFTRAG////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

IF s0 AND NOT s26a AND Auftrag.Art = 'Ladeauftrag' THEN
	s0 := 0; s26a := 1;
	lastRelevantStateForCollision := 's26a';
	//	RückmeldugGW1 Auftrag angenommen setzt
	FeedbackToGW1 := 'Auftrag angenommen';
	//Auftrag auswerten
	readAssigment(assigment:= Auftrag);
	EndNode := readAssigment.endNodeCharging;
	xEndvalue := readAssigment.chargingLocation.x;
	yEndvalue := readAssigment.chargingLocation.y;
	xRobotStartposition := camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].x;
	yRobotStartposition := camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].y;	
END_IF

IF s26a AND NOT s26b AND xRobotStartposition <> 0 AND yRobotStartposition <> 0 THEN
	AStar(xRobotActual := xRobotStartposition, yRobotActual := yRobotStartposition, xEnd := xEndvalue, yEnd := yEndvalue, endNode := EndNode, blockedNodes := removeNodeCollision);
	finished_ASearch := AStar.finishedASearch;
	IF finished_ASearch THEN
		xPointList := AStar.xCoordinates;
		yPointList := AStar.yCoordinates;
		s26a := 0; s26b := 1;
	END_IF
ELSIF s26a AND NOT s26b THEN
	xRobotStartposition := actualCamX;
	yRobotStartposition := actualCamY;
END_IF

//Bahnplanung
IF s26b AND NOT s27 AND finished_ASearch THEN
	ZEROS_RobotPoseSimple(wayPointList);
	ZEROS_INT(removeNodeCollision);
	finished_ASearch := FALSE;
	FOR i := 0 TO 100 BY 1 DO
 		wayPointList[i] := ToRobotPoseSimple(x:= xPointList[i], y:= yPointList[i], theta:= -1);
		IF xPointList[i] = 0 THEN
			zeile := i;
			EXIT;
		END_IF
	END_FOR
	wayPointList[zeile] := readAssigment.chargingLocation;
	wayPointList[zeile+1] := ToRobotPoseSimple(x := -1, y := -1, theta := -1);
	TrajectoryController.setWaypointList(waypointList);
	trajectoryController.newWaypointListAvailable := TRUE;
	resetVarMQTT := TRUE;															//testen
	s26b := 0; s27 := 1;
END_IF

///////////////////////////////////////////////FahrtZurStation///////////////////////////////////////////////////

// 	RückmeldungGW3 Wegpunkte erhalten abwarten
IF s27 AND NOT s28 AND trajectoryController.yControllerState = ControllerState.setTrajectory THEN
	s27 := 0; s28 := 1;
	trajectoryController.newWaypointListAvailable := FALSE;
END_IF

// 	RückmeldungGW3 ready abwarten
IF s28 AND NOT s29 AND trajectoryController.yControllerState = ControllerState.ready THEN
	s28 := 0; s29 := 1;
	trajectoryController.xBoEnable := TRUE;
END_IF
	
//	RückmeldungGW3 Fahrt abwarten
IF s29 AND NOT s30 AND trajectoryController.yControllerState = ControllerState.driving THEN
	s29 := 0; s30 := 1;
	//	RückmeldungGW1 Auf Anfahrt setzen
	FeedbackToGW1 := 'Auf Anfahrt';
END_IF

//	RückmeldungGW3 am Ziel abwarten
IF s30 AND NOT s31 AND trajectoryController.yBoArrivedAtDestination THEN
	s30 := 0; s31 := 1;
	lastRelevantStateForCollision := 's31';
	trajectoryController.xBoEnable := FALSE;
	resetVarMQTT := FALSE;															//testen
	//	RückmeldungGW1 Teil aufgenommen setzen
	FeedbackToGW1 := 'An Ladestation';
END_IF

IF s31 AND NOT s32 AND StatusFromGW1 = 'FertigGeladen' THEN
	s31 := 0; s32 := 1; //s21a := 1;
	lastRelevantStateForCollision := 's32';
	//	Fahrauftrag von Ladestation weg
	ZEROS_RobotPoseSimple(wayPointList);
	ZEROS_INT(removeNodeCollision);
	wayPointList[0] := readAssigment.lastNodeCharging;
	wayPointList[1] := ToRobotPoseSimple(x := -1, y := -1, theta := -1); 
	TrajectoryController.setWaypointList(waypointList);
	trajectoryController.newWaypointListAvailable := TRUE;
	resetVarMQTT := TRUE;									
END_IF
	
// 	RückmeldungGW3 Wegpunkte erhalten abwarten
IF s32 AND NOT s33 AND trajectoryController.yControllerState = ControllerState.setTrajectory THEN
	s32 := 0; s33 := 1;
	trajectoryController.newWaypointListAvailable := FALSE;
END_IF

// 	RückmeldungGW3 ready abwarten
IF s33 AND NOT s34 AND trajectoryController.yControllerState = ControllerState.ready THEN
	s33 := 0; s34 := 1;
	trajectoryController.xBoEnable := TRUE;
END_IF
	
//	RückmeldungGW3 Fahrt abwarten
IF s34 AND NOT s35 AND trajectoryController.yControllerState = ControllerState.driving THEN
	s34 := 0; s35 := 1;
END_IF

//	RückmeldungGW3 am Ziel abwarten
IF s35 AND NOT s21a AND trajectoryController.yBoArrivedAtDestination THEN
	s35 := 0; s21a := 1;
	lastRelevantStateForCollision := 's21a';
	trajectoryController.xBoEnable := FALSE;
	resetVarMQTT := FALSE;														
	//	RückmeldungGW1 Teil aufgenommen setzen
	FeedbackToGW1 := 'Verfuegbar';
	EndNode := readAssigment.endNodeParking[Var_HAWIno.Robot_Number];															
	xEndvalue := readAssigment.parkingSlots[Var_HAWIno.Robot_Number].x;
	yEndvalue := readAssigment.parkingSlots[Var_HAWIno.Robot_Number].y;
	xRobotStartposition := camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].x;
	yRobotStartposition := camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].y;	
END_IF


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////Parkplatzanfahrt///////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

IF s21a AND NOT s21b AND xRobotStartposition <> 0 AND yRobotStartposition <> 0 AND gripper.state = CoreGripperControlState.Closed THEN
	AStar(xRobotActual := xRobotStartposition, yRobotActual := yRobotStartposition, xEnd := xEndvalue, yEnd := yEndvalue, endNode := EndNode, blockedNodes := removeNodeCollision);
	finished_ASearch := AStar.finishedASearch;
	IF finished_ASearch THEN
		xPointList := AStar.xCoordinates;
		yPointList := AStar.yCoordinates;
		s21a := 0; s21b := 1;
	END_IF
ELSIF s21a AND NOT s21b THEN
	//IF readAssigment.assigment.AbholTasche < 3 THEN	
	//	xRobotStartposition := actualCamX - 200;
	//ELSE
	//	xRobotStartposition := actualCamX + 200;
	//END_IF
	xRobotStartposition := actualCamX;
	yRobotStartposition := actualCamY;
END_IF

//Bahnplanung
IF s21b AND NOT s22 AND finished_ASearch THEN
	ZEROS_RobotPoseSimple(wayPointList);
	ZEROS_INT(removeNodeCollision);
	finished_ASearch := FALSE;
	FOR i := 0 TO 100 BY 1 DO
 		wayPointList[i] := ToRobotPoseSimple(x:= xPointList[i], y:= yPointList[i], theta:= -1);
		IF xPointList[i] = 0 THEN
			zeile := i;
			EXIT;
		END_IF
	END_FOR
	wayPointList[zeile] := readAssigment.parkingSlots[Var_HAWIno.Robot_Number];
	wayPointList[zeile+1] := ToRobotPoseSimple(x := -1, y := -1, theta := -1);
	TrajectoryController.setWaypointList(waypointList);
	trajectoryController.newWaypointListAvailable := TRUE;
	s21b := 0; s22 := 1;
END_IF


///////////////////////////////////////////////////FahrtZumParkplatz////////////////////////////////////////////////////////
 
// 	RückmeldungGW3 Wegpunkte erhalten abwarten
IF s22 AND NOT s23 AND trajectoryController.yControllerState = ControllerState.setTrajectory THEN
	s22 := 0; s23 := 1;
	trajectoryController.newWaypointListAvailable := FALSE;
END_IF

// 	RückmeldungGW3 ready abwarten
IF s23 AND NOT s24 AND trajectoryController.yControllerState = ControllerState.ready THEN
	s23 := 0; s24 := 1;
	trajectoryController.xBoEnable := TRUE;
END_IF
	
//	RückmeldungGW3 Fahrt abwarten
IF s24 AND NOT s25 AND trajectoryController.yControllerState = ControllerState.driving THEN
	s24 := 0; s25 := 1;
	//kann schon nächsten Auftrag annehmen
	FeedbackToGW1 := 'Verfuegbar';
END_IF

IF s25 AND NOT s25b AND trajectoryController.yControllerState = ControllerState.driving AND Auftrag.Art = 'Fahrauftrag' THEN
	lastRelevantStateForCollision := 's0';
	trajectoryController.xBoEnable := FALSE;
	s25 := 0; s25b := 1;
END_IF

IF s25b AND NOT s0 AND trajectoryController.yControllerState = ControllerState.ready THEN
	s25b := 0; s0 := 1;
END_IF

//	RückmeldungGW3 am Ziel abwarten
IF s25 AND NOT s0 AND trajectoryController.yBoArrivedAtDestination THEN
	s25 := 0; s0 := 1;
	lastRelevantStateForCollision := 's0';
	trajectoryController.xBoEnable := FALSE;
	//	RückmeldungGW1 Verfügbar
	FeedbackToGW1 := 'Verfuegbar';
END_IF

////////////////////////////////////////////////////////RESET und ERROR/////////////////////////////////////////////////////
IF reset AND NOT s31 THEN //nur wenn nicht an der Ladestation
	TrajectoryController.xBoEnable := FALSE;
	doReset();
	resetTimer.PT := T#1S;
	resetTimer.IN := TRUE;
END_IF

IF Auftrag.Art = '' AND (trajectoryController.yControllerState = ControllerState.idle OR trajectoryController.yControllerState = ControllerState.ready) AND resetTimer.Q THEN
	//reset zurücksetzen
	resetTimer.IN := FALSE;
	reset := FALSE;
	readAssigment(assigment := Auftrag);
	EndNode := readAssigment.endNodeParking[Var_HAWIno.Robot_Number];															//todo in matlab
	xEndvalue := readAssigment.parkingSlots[Var_HAWIno.Robot_Number].x;
	yEndvalue := readAssigment.parkingSlots[Var_HAWIno.Robot_Number].y;
	xRobotStartposition := camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].x;
	yRobotStartposition := camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].y;	
	s21a := TRUE;
	lastRelevantStateForCollision := 's21a';
	resetVarMQTT := FALSE;
	TrajectoryController.xBoReset := FALSE;
END_IF

IF AStar.AStarFailed THEN
	failedCounter := failedCounter + 1;
ELSE
	failedCounter := 1;
END_IF]]></ST>
    </Implementation>
    <Method Name="CameraDataSaved" Id="{2f9f9f5b-81b2-40e5-9ec2-0422cd042c9a}">
      <Declaration><![CDATA[METHOD CameraDataSaved : BOOL
VAR_INPUT
END_VAR

VAR
	n: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR n := 1 TO 4 BY 1 DO
	IF camera.cameraData.robotPositionArray[n].x <> 0 AND camera.cameraData.robotPositionArray[n].y <> 0 THEN
		cameraX[n] := camera.cameraData.robotPositionArray[n].x;
		cameraY[n] := camera.cameraData.robotPositionArray[n].y;
	END_IF
END_FOR
]]></ST>
      </Implementation>
    </Method>
    <Method Name="CollisionsSolution_new" Id="{b549cdcd-badb-48a4-b744-c413f414dadb}">
      <Declaration><![CDATA[METHOD CollisionsSolution_new : BOOL
VAR_INPUT
END_VAR
VAR
	n, higherXRobo, lowerXRobo : INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[otherRoboInfo();
collisionSolutionWorking := TRUE;
/////////////////////////////////////////////////////////////////NORMAL////////////////////////////////////////////////////////////////////////

IF sk0 AND NOT sk1 AND NOT otherRoboAtStation AND NOT thisRoboAtStation AND NOT otherRoboAtStop AND timerCollision.Q THEN
	todo := 'Warten';
	//darf ich fahren? nur wenn kleinere Roboternummer
	FOR n := 0 TO 4 BY 1 DO
		IF otherRobo[n] > Var_HAWIno.Robot_Number THEN
			todo := 'Fahren';
		END_IF
	END_FOR
	sk0 := 0; sk1 := 1;
	timerCollision.IN := FALSE;
END_IF

IF sk1 AND NOT sk2 AND todo = 'Fahren' THEN
	findNodesToRemove(collisionRobo := otherRobo);
	
	//in richtigen State zurück zum neuplanen und weiterfahren
	xRobotStartposition := camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].x;
	yRobotStartposition := camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].y;	
	continueAfterCollision();
	todo := '';
	sk1 := 0; sk2 := 1;
END_IF

IF sk1 AND NOT sk3 AND todo = 'Warten' THEN
	sk1 := 0; sk3 := 1;
END_IF

IF sk3 AND NOT sk4 AND collisionFree THEN
	xRobotStartposition := camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].x;
	yRobotStartposition := camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].y;
	continueAfterCollision();
	todo := '';
	sk3 := 0; sk4 := 1;
END_IF

IF sk2 OR sk4 THEN
	sk2 := 0; sk4 := 0; 
	resetCollision();
END_IF


/////////////////////////////////////////////////////////////ATSTOP////////////////////////////////////////////////////////////////////////////

IF sk0 AND NOT sk10 AND otherRoboAtStop AND timerCollision.Q THEN
	findNodesToRemove(collisionRobo := otherRobo);
	
	xRobotStartposition := camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].x;
	yRobotStartposition := camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].y;
	continueAfterCollision();
	timerCollision.IN := FALSE;
	sk0 := 0; sk10 := 1;
END_IF

IF sk10 THEN
	sk10 := 0;
	resetCollision();
END_IF


//////////////////////////////////////////////////////////////ATSTATION///////////////////////////////////////////////////////////////////////////

IF sk0 AND NOT sk20 AND (otherRoboAtStation OR thisRoboAtStation) AND timerCollision.Q THEN
	sk0 := 0; sk20 := 1;
	timerCollision.IN := FALSE;
END_IF

//nur anderer Robo an Station
IF sk20 AND NOT sk21 AND otherRoboAtStation AND NOT thisRoboAtStation THEN
	drivingBack();
	IF resetGoBack THEN
		sk20 := 0; sk21 := 1;
	END_IF
END_IF

IF sk21 AND NOT sk22 AND NOT otherRoboAtStation THEN
	xRobotStartposition := camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].x;
	yRobotStartposition := camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].y;
	continueAfterCollision();
	sk21 := 0; sk22 := 1;
END_IF

//nur dieser Robo an Station
IF sk20 AND NOT sk23 AND NOT otherRoboAtStation AND thisRoboAtStation THEN
	findNodesToRemove(collisionRobo := otherRobo);
	
	//in richtigen State zurück zum neuplanen und weiterfahren
	xRobotStartposition := camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].x;
	yRobotStartposition := camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].y;	
	continueAfterCollision();
	sk20 := 0; sk23 := 1;
END_IF

//beide an Station
IF sk20 AND NOT sk24 AND otherRoboAtStation AND thisRoboAtStation THEN
	sk20 := 0; sk24 := 1;
	//checken, ob an gleicher Station
	higherXRobo := SEL((camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].x > camera.cameraData.robotPositionArray[otherRobo[0]].x), otherRobo[0], Var_HAWIno.Robot_Number);
	lowerXRobo := SEL((camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].x < camera.cameraData.robotPositionArray[otherRobo[0]].x), otherRobo[0], Var_HAWIno.Robot_Number);
	IF camera.cameraData.robotPositionArray[higherXRobo].theta > 3 and camera.cameraData.robotPositionArray[higherXRobo].theta < -3 AND camera.cameraData.robotPositionArray[lowerXRobo].theta > -0.1 AND camera.cameraData.robotPositionArray[lowerXRobo].theta < 0.1 THEN
		sameStation := TRUE;
	ELSE
		sameStation := FALSE;
	END_IF  
END_IF

//an gleicher Station
IF sk24 AND NOT sk25 AND sameStation THEN
	xRobotStartposition := camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].x;
	yRobotStartposition := camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].y;	
	continueAfterCollision();
	sk24 := 0; sk25 := 1;
	//hier weiteren state 
END_IF

//gleicher Bereich nicht gleiche Station
IF sk24 AND NOT sk26 AND NOT sameStation THEN
	sk24 := 0; sk26 := 1;
END_IF

//dieser Robo auf Transport an Station
IF sk26 AND NOT sk27 AND drivingAtStation THEN
	xRobotStartposition := camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].x;
	yRobotStartposition := camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].y;	
	continueAfterCollision();
	sk26 := 0; sk27 := 1;
END_IF

//dieser nicht aber anderer auf Transport an Station
IF sk26 AND NOT sk28 AND NOT drivingAtStation AND goBack THEN
	drivingBack();
	IF resetGoBack THEN
		sk26 := 0; sk28 := 1;
	END_IF
END_IF

IF sk28 AND NOT sk29 AND NOT otherRoboAtStation THEN
	xRobotStartposition := camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].x;
	yRobotStartposition := camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].y;	
	continueAfterCollision();
	sk28 := 0; sk29 := 1;
END_IF

//beide im Stationsbereich und keiner auf Transport an Station
IF sk26 AND NOT sk30 AND NOT drivingAtStation AND NOT goBack THEN
	todo := 'Warten';
	//darf ich fahren? nur wenn kleinere Roboternummer
	//FOR n := 0 TO 4 BY 1 DO
	//	IF otherRobo[n] > Var_HAWIno.Robot_Number THEN
	//		todo := 'Fahren';
	//	END_IF
	//END_FOR			
	IF SQRT(EXPT(camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].x - AStar.xEnd,2) + EXPT(camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].x - 2800,2)) < SQRT(EXPT(camera.cameraData.robotPositionArray[otherRobo[0]].x - AStar.xEnd,2) + EXPT(camera.cameraData.robotPositionArray[otherRobo[0]].x - 2800,2)) THEN
		//dieser Robo dichter dran
		todo := 'Fahren';
	END_IF
	sk26 := 0; sk30 := 1;
END_IF

IF sk30 AND NOT sk31 AND todo = 'Fahren' THEN
	xRobotStartposition := camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].x;
	yRobotStartposition := camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].y;	
	continueAfterCollision();
	sk30 := 0; sk31 := 1;
END_IF

IF sk30 AND NOT sk32 AND todo = 'Warten' THEN
	drivingBack();
	IF resetGoBack THEN
		sk30 := 0; sk32 := 1;
	END_IF
END_IF

IF sk32 AND NOT sk33 AND NOT otherRoboAtStation THEN
	xRobotStartposition := camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].x;
	yRobotStartposition := camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].y;	
	continueAfterCollision();
	sk30 := 0; sk31 := 1;
END_IF

IF resetGoBack AND NOT goBack THEN
	resetGoBack := FALSE;
END_IF

/////////////////////////////////////////Am Ende der Kollisionsauflösung//////////////////////////////////////////////
IF sk22 OR sk23 OR sk25 OR sk27 OR sk29 OR sk31 OR sk33 THEN
	sk22 := 0; sk23 := 0; sk25 := 0; sk27 := 0; sk29 := 0; sk31 := 0; sk33 := 0;
	resetCollision();
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="continueAfterCollision" Id="{bdb23939-8772-4122-86ab-be757c2f916b}">
      <Declaration><![CDATA[METHOD continueAfterCollision : BOOL
VAR_INPUT
END_VAR
VAR
	diffToList : ARRAY[0..100] OF LREAL;
	sortedDiff : ARRAY[0..100,1..2] OF LREAL;
	nextIndex, j, n, l, i : INT;
	nullSortedDiff : ARRAY[0..100,1..2] OF LREAL := [202(0)];
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF lastRelevantStateForCollision = 's0' THEN
	s0 := 1;
ELSIF lastRelevantStateForCollision = 's1a' THEN
	s1a := 1;
ELSIF lastRelevantStateForCollision = 's6a' THEN
	s6a := 1;
ELSIF lastRelevantStateForCollision = 's6b' THEN
	s6b := 1;
	//Greifer muss zu, was passiert hier
	//readAssigment.pointsFromSlotToReader
	//Arrays resetten
	ZEROS(diffToList);
	sortedDiff := nullSortedDiff;
	
	FOR i := 0 TO 10 BY 1 DO
		IF readAssigment.pointsFromSlotToReader[i].x > 0 AND readAssigment.pointsFromSlotToReader[i].y > 0 THEN
			//Abstände Roboter zu Wegpunkten
			diffToList[i] := SQRT(EXPT(camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].x - readAssigment.pointsFromSlotToReader[i].x,2) + EXPT(camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].y - readAssigment.pointsFromSlotToReader[i].y,2));
			FOR n := 0 TO 10 BY 1 DO
				IF diffToList[i] < sortedDiff[n,2] THEN
					FOR l := 9 TO n BY -1 DO
						sortedDiff[l+1,1] := sortedDiff[l,1];
						sortedDiff[l+1,2] := sortedDiff[l,2];
					END_FOR
					sortedDiff[n,2] := diffToList[i];
					sortedDiff[n,1] := i;
					EXIT;
				ELSIF i = 0 THEN
					sortedDiff[0,2] := diffToList[0];
					sortedDiff[0,1] := 0;
					EXIT;
				END_IF
			END_FOR
		END_IF	
	END_FOR
	
	ZEROS_RobotPoseSimple(wayPointList);
	nextIndex := LREAL_TO_INT(MAX(sortedDiff[0,1],sortedDiff[1,1]));
	
	FOR i := 0 TO 100 - nextIndex BY 1 DO 
		wayPointList[i] := readAssigment.pointsFromSlotToReader[nextIndex + i];
	END_FOR 
	TrajectoryController.setWaypointList(wayPointList);
	trajectoryController.newWaypointListAvailable := TRUE;

ELSIF lastRelevantStateForCollision = 's10' THEN
	s10 := 1;
ELSIF lastRelevantStateForCollision = 's11a' THEN
	s11a := 1;
ELSIF lastRelevantStateForCollision = 's16' THEN
	s16 := 1;
ELSIF lastRelevantStateForCollision = 's17' THEN
	s17 := 1;
	//readAssigment.pointsFromReaderToSlot
	//Arrays resetten
	ZEROS(diffToList);
	sortedDiff := nullSortedDiff;
	
	FOR i := 0 TO 10 BY 1 DO
		IF readAssigment.pointsFromReaderToSlot[i].x <> 0 AND readAssigment.pointsFromReaderToSlot[i].y <> -1 THEN
			//Abstände Roboter zu Wegpunkten
			diffToList[i] := SQRT(EXPT(camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].x - readAssigment.pointsFromReaderToSlot[i].x,2) + EXPT(camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].y - readAssigment.pointsFromReaderToSlot[i].y,2));
			FOR n := 0 TO 10 BY 1 DO
				IF diffToList[i] < sortedDiff[n,2] THEN
					FOR l := 9 TO n BY -1 DO
						sortedDiff[l+1,1] := sortedDiff[l,1];
						sortedDiff[l+1,2] := sortedDiff[l,2];
					END_FOR
					sortedDiff[n,2] := diffToList[i];
					sortedDiff[n,1] := i;
					EXIT;
				ELSIF i = 0 THEN
					sortedDiff[0,2] := diffToList[0];
					sortedDiff[0,1] := 0;
					EXIT;
				END_IF
			END_FOR
		END_IF	
	END_FOR
	
	ZEROS_RobotPoseSimple(wayPointList);
	nextIndex := LREAL_TO_INT(MAX(sortedDiff[0,1],sortedDiff[1,1]));
	
	FOR i := 0 TO 100 - nextIndex BY 1 DO 
		wayPointList[i] := readAssigment.pointsFromReaderToSlot[nextIndex + i];
	END_FOR 
	TrajectoryController.setWaypointList(wayPointList);
	trajectoryController.newWaypointListAvailable := TRUE;
	
ELSIF lastRelevantStateForCollision = 's21a' THEN
	s21a := 1;
ELSIF lastRelevantStateForCollision = 's26a' THEN
	s26a := 1;
ELSIF lastRelevantStateForCollision = 's31' THEN
	s31 := 1;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="doReset" Id="{11fc1a94-8006-4f54-bbc3-6cfe2505c8b8}">
      <Declaration><![CDATA[METHOD doReset : BOOL
VAR_INPUT
	
END_VAR

]]></Declaration>
      <Implementation>
        <ST><![CDATA[resetVarMQTT := TRUE;
TrajectoryController.xBoReset := TRUE;
ZEROS_RobotPoseSimple(wayPointList);
actualCamX := 0;
actualCamY := 0;
trajectoryController.newWaypointListAvailable := FALSE;
trajectoryController.xBoEnable := FALSE;
FeedbackToGW1 := 'Verfuegbar';
closeGripperCommand := FALSE;
ZEROS_INT(removeNodeCollision);
error := FALSE;
failedCounter := 1;

//Statemaschine zurücksetzen
sStart := FALSE;
s0 := FALSE;
s1a := FALSE;
s1b := FALSE;
s2 := FALSE;
s3 := FALSE;
s4 := FALSE;
s5 := FALSE;
s6a := FALSE;
s6b := FALSE;
s7 := FALSE;
s8 := FALSE;
s9 := FALSE;
s10 := FALSE;
s11a := FALSE;
s11b := FALSE;
s12 := FALSE;
s13 := FALSE;
s14 := FALSE;
s15 := FALSE;
s16 := FALSE;
s17 := FALSE;
s18 := FALSE;
s19 := FALSE;
s20 := FALSE;
s21a := FALSE;
s21b := FALSE;
s22 := FALSE;
s23 := FALSE;
s24 := FALSE;
s25 := FALSE;
s26a := FALSE;
s26b := FALSE;
s27 := FALSE;
s28 := FALSE;
s29 := FALSE;
s30 := FALSE;
s31 := FALSE;

resetCollision();

]]></ST>
      </Implementation>
    </Method>
    <Method Name="drivingBack" Id="{62bdf92e-d532-4d8c-b162-66ce008d6195}">
      <Declaration><![CDATA[METHOD drivingBack : BOOL
VAR_INPUT
END_VAR

VAR
	gbWayPointList : ARRAY[0..100] OF RobotPoseSimple;
	diffToList : ARRAY[0..100] OF LREAL;
	sortedDiff : ARRAY[0..100,1..2] OF LREAL;
	index, n, l, i : INT;
	camX, camY : LREAL;
	alternativeGoAway: BOOL;
	nullSortedDiff : ARRAY[0..100,1..2] OF LREAL := [202(0)];
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF firstTime THEN //hier and goBack entfernt
	//Arrays resetten
	ZEROS_RobotPoseSimple(gbWayPointList);
	ZEROS(diffToList);
	sortedDiff := nullSortedDiff;
	alternativeGoAway := FALSE;

	camX := camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].x;
	camY := camera.cameraData.robotPositionArray[Var_HAWIno.Robot_Number].y;
	IF camX = 0 AND camY = 0 THEN
		camX := actualCamX;
		camY := actualCamY;
	END_IF
	
	FOR i := 0 TO 100 BY 1 DO
		IF wayPointList[i].x <> 0 AND wayPointList[i].y <> 0 THEN
			//Abstände Roboter zu Wegpunkten
			diffToList[i] := SQRT(EXPT(camX - wayPointList[i].x,2) + EXPT(camY - wayPointList[i].y,2));
			FOR n := 0 TO 100 BY 1 DO
				IF diffToList[i] < sortedDiff[n,2] THEN
					FOR l := 99 TO n BY -1 DO
						sortedDiff[l+1,1] := sortedDiff[l,1];
						sortedDiff[l+1,2] := sortedDiff[l,2];
					END_FOR
					sortedDiff[n,2] := diffToList[i];
					sortedDiff[n,1] := i;
					EXIT;
				ELSIF i = 0 THEN
					sortedDiff[0,2] := diffToList[0];
					sortedDiff[0,1] := 0;
					EXIT;
				ELSIF sortedDiff[n+1,2] = 0 THEN
					sortedDiff[n+1,2] := diffToList[i];
					sortedDiff[n+1,1] := i;
					EXIT;
				END_IF
			END_FOR
		END_IF	
	END_FOR
	
	index := LREAL_TO_INT(MIN(sortedDiff[0,1],sortedDiff[1,1]));

	IF index > 1 THEN
		gbWaypointList[0] := wayPointList[index];
		gbWaypointList[1] := wayPointList[index-1];
		gbWaypointList[2] := wayPointList[index-2];
		gbWaypointList[3] := ToRobotPoseSimple(x := -1, y := -1, theta := -1);
	ELSE
		alternativeGoAway := TRUE;
	END_IF
	
	TrajectoryController.setWaypointList(gbWaypointList);
	trajectoryController.newWaypointListAvailable := TRUE;
	firstTime := FALSE;
END_IF

IF trajectoryController.yControllerState = ControllerState.setTrajectory THEN //hier and goBack entfernt
	trajectoryController.newWaypointListAvailable := FALSE;
END_IF

// 	RückmeldungGW3 ready abwarten
IF trajectoryController.yControllerState = ControllerState.ready THEN //hier and goBack entfernt
	trajectoryController.xBoEnable := TRUE;
END_IF

IF trajectoryController.yBoArrivedAtDestination THEN //hier and goBack entfernt
	trajectoryController.xBoEnable := FALSE;
	resetGoBack := true;
	firstTime := TRUE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="errorTest" Id="{e469cc9c-ca1f-4674-b1dd-16db9e33a62d}">
      <Declaration><![CDATA[METHOD errorTest : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//ERROR: Teil verloren
IF gripper.state = CoreGripperControlState.Open AND Gripper.partGripped THEN
	error := TRUE;
	TrajectoryController.xBoEnable := FALSE;	
	removeAllToken();
	FeedbackToGW1 := 'Error Teil verloren';
	closeGripperCommand := FALSE;
	resetVarMQTT := FALSE;
END_IF
	
//ERROR: Error von GW3
IF trajectoryController.yControllerState = ControllerState.error THEN
	error := TRUE;
	removeAllToken();
	FeedbackToGW1 := 'Error Bumper';
	closeGripperCommand := FALSE;
	resetVarMQTT := FALSE;
END_IF

//wenn AStern auch nach 1000 Zyklen Failed
IF failedCounter > 1000 THEN
	error := TRUE;
	//removeAllToken();
	FeedbackToGW1 := 'Fehler AStar';
	closeGripperCommand := FALSE;
	resetVarMQTT := FALSE;
	//wenn Kollision anderen Wegschicken?
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="findNodesToRemove" Id="{ef8384d2-b9d5-47a0-af76-48b877d17d18}">
      <Declaration><![CDATA[METHOD findNodesToRemove : BOOL
VAR_INPUT
	collisionRobo : ARRAY[0..4] OF INT;
END_VAR
VAR
	xMinBox, xMaxBox, yMinBox, yMaxBox, row, col : LREAL;
	xNode, yNode : ARRAY[1..170] OF LREAL;
	d, j, w : INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//abfangen wenn keine Kameradaten da?
w := 1;

FOR d := 0 TO 4 BY 1 DO
	IF collisionRobo[d] <> 0 THEN
		//Umrechnung von Knoten in Koordinaten
		 row := 600;
		 col := 200;
		 
		 FOR i := 1 TO 144 BY 1 DO
			 IF xNode[i] <> 10000 THEN
				xNode[i] := col;
			 END_IF
			 IF yNode[i] <> 10000 THEN
				yNode[i] := row;
			 END_IF
			 col := col + 400;
			 IF i MOD 18 = 0 THEN
				 col := 200;
				 row := row + 400;
			 END_IF
		 END_FOR
		 
		 xNode[145] := 850;
		 xNode[146] := 850;
		 xNode[147] := 850;
		 xNode[148] := 1350;
		 xNode[149] := 1350;
		 xNode[150] := 1350;
		 xNode[151] := 2050;
		 xNode[152] := 2050;
		 xNode[153] := 2050;
		 xNode[154] := 2490;
		 xNode[155] := 2490;
		 xNode[156] := 2490;
		 xNode[157] := 3190;
		 xNode[158] := 3190;
		 xNode[159] := 3190;
		 xNode[160] := 3700;
		 xNode[161] := 3700;
		 xNode[162] := 3700;
		 xNode[163] := 4420;
		 xNode[164] := 4420;
		 xNode[165] := 4420;
		 xNode[166] := 4940;
		 xNode[167] := 4940;
		 xNode[168] := 4940;
		 xNode[169] := 6117;
		 xNode[170] := 6716;
		 
		 yNode[145] := 2735;
		 yNode[146] := 2838;
		 yNode[147] := 2936;
		 yNode[148] := 2736;
		 yNode[149] := 2835;
		 yNode[150] := 2935;
		 yNode[151] := 2731;
		 yNode[152] := 2829;
		 yNode[153] := 2931;
		 yNode[154] := 2732;
		 yNode[155] := 2833;
		 yNode[156] := 2928;
		 yNode[157] := 2732;
		 yNode[158] := 2837;
		 yNode[159] := 2940;
		 yNode[160] := 2732;
		 yNode[161] := 2840;
		 yNode[162] := 2940;
		 yNode[163] := 2732;
		 yNode[164] := 2838;
		 yNode[165] := 2944;
		 yNode[166] := 2746;
		 yNode[167] := 2855;
		 yNode[168] := 2942;
		 yNode[169] := 3450;
		 yNode[170] := 3450;
		 
		
		//im Abstand von 400 all Knoten um Robot löschen
		IF camera.cameraData.robotPositionArray[collisionRobo[d]].x <> 0 AND camera.cameraData.robotPositionArray[collisionRobo[d]].y <> 0 THEN
			xMinBox := camera.cameraData.robotPositionArray[collisionRobo[d]].x - 400;
			xMaxBox := camera.cameraData.robotPositionArray[collisionRobo[d]].x + 400;
			yMinBox := camera.cameraData.robotPositionArray[collisionRobo[d]].y - 400;
			yMaxBox := camera.cameraData.robotPositionArray[collisionRobo[d]].y + 400;
		ELSE 
			xMinBox := cameraX[collisionRobo[d]] - 400;
			xMaxBox := cameraX[collisionRobo[d]] + 400;
			yMinBox := cameraY[collisionRobo[d]] - 400;
			yMaxBox := cameraY[collisionRobo[d]] + 400;
		END_IF
		
		FOR j := 1 TO 170 BY 1 DO
			IF xNode[j] > xMinBox AND xNode[j] < xMaxBox AND yNode[j] > yMinBox AND yNode[j] < yMaxBox THEN
				removeNodeCollision[w] := j;
				w := w + 1;
			END_IF
		END_FOR
	END_IF
END_FOR
]]></ST>
      </Implementation>
    </Method>
    <Method Name="otherRoboInfo" Id="{e2679d78-4ec4-4c4f-a55e-7f22b5fbb268}">
      <Declaration><![CDATA[METHOD otherRoboInfo : BOOL
VAR_INPUT
END_VAR
VAR
	nmb, z: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[CameraDataSaved();

IF newCollision THEN
	removeAllToken();
	i := 0;
	FOR nmb := 0 TO 4 BY 1 DO
		IF collision[nmb] AND nmb <> Var_HAWIno.Robot_Number THEN
			otherRobo[i] := nmb;
			i := i + 1;
		END_IF
	END_FOR
END_IF

IF otherRobo[0] > 0 THEN
	IF cameraY[otherRobo[0]] < 650 THEN
		//Anderer Roboter auf Parkplatz
		otherRoboAtStop := TRUE;	
	ELSIF cameraX[otherRobo[0]] > 6100 AND cameraX[otherRobo[0]] < 6800 AND cameraY[otherRobo[0]] > 3400 AND cameraY[otherRobo[0]] < 3600  THEN
		//Anderer Roboter an Ladestation
		otherRoboAtStop := TRUE;
	ELSE
		otherRoboAtStop := FALSE;
	END_IF
	
	IF cameraX[otherRobo[0]] > 0 AND cameraX[otherRobo[0]] < 5200 AND cameraY[otherRobo[0]] > 2340 AND cameraY[otherRobo[0]] < 3345  THEN
		//Anderer Roboter im Bereich der Stationen
		otherRoboAtStation := TRUE;
	ELSE
		otherRoboAtStation := FALSE;
	END_IF
	
	IF cameraX[Var_HAWIno.Robot_Number] > 0 AND cameraX[Var_HAWIno.Robot_Number] < 5200 AND cameraY[Var_HAWIno.Robot_Number] > 2340 AND cameraY[Var_HAWIno.Robot_Number] < 3345  THEN
		thisRoboAtStation := TRUE;
	ELSE
		thisRoboAtStation := FALSE;
	END_IF
	
	//Stationsfahrt: anderen Robo wegschicken -> Timer nötig????
	IF lastRelevantStateForCollision = 's6a' OR lastRelevantStateForCollision = 's6b' OR lastRelevantStateForCollision = 's10' OR lastRelevantStateForCollision = 's16' OR lastRelevantStateForCollision = 's17' THEN
		//anderen Wegschicken
		FOR z := 0 TO 4 DO
			IF newCollision AND otherRobo[z] <> 0 THEN
				RoboNmbToGoBack[z] := otherRobo[z];
			ELSIF NOT otherRoboAtStation THEN
				RoboNmbToGoBack[z] := 0;
			END_IF 
			drivingAtStation := TRUE;
		END_FOR
	ELSE
		drivingAtStation := FALSE;
	END_IF
ELSE
	error := TRUE;
	removeAllToken();
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="removeAllToken" Id="{ae306339-8136-4758-9f9e-43c55251323b}">
      <Declaration><![CDATA[METHOD removeAllToken : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Statemaschine zurücksetzen
sStart := FALSE;
s0 := FALSE;
s1a := FALSE;
s1b := FALSE;
s2 := FALSE;
s3 := FALSE;
s4 := FALSE;
s5 := FALSE;
s6a := FALSE;
s6b := FALSE;
s7 := FALSE;
s8 := FALSE;
s9 := FALSE;
s10 := FALSE;
s11a := FALSE;
s11b := FALSE;
s12 := FALSE;
s13 := FALSE;
s14 := FALSE;
s15 := FALSE;
s16 := FALSE;
s17 := FALSE;
s18 := FALSE;
s19 := FALSE;
s20 := FALSE;
s21a := FALSE;
s21b := FALSE;
s22 := FALSE;
s23 := FALSE;
s24 := FALSE;
s25 := FALSE;
s26a := FALSE;
s26b := FALSE;
s27 := FALSE;
s28 := FALSE;
s29 := FALSE;
s30 := FALSE;
s31 := FALSE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="resetCollision" Id="{55e9b937-ae96-4a1c-b254-a88952f35d6c}">
      <Declaration><![CDATA[METHOD resetCollision : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[collisionSolutionWorking := FALSE; //Kollision behoben

Zeros_INT(otherRobo);
otherRoboAtStop := FALSE;
otherRoboAtStation := FALSE;
thisRoboAtStation := FALSE;
RoboNmbToGoBack[0] := 0;
RoboNmbToGoBack[1] := 0;
RoboNmbToGoBack[2] := 0;
RoboNmbToGoBack[3] := 0;
RoboNmbToGoBack[4] := 0;
drivingAtStation := FALSE;
sameStation := FALSE;
todo := '';

sk0 := FALSE;
sk1 := FALSE;
sk2 := FALSE;
sk3 := FALSE;
sk4 := FALSE;
sk10 := FALSE;
sk20 := FALSE;
sk21 := FALSE;
sk22 := FALSE;
sk23 := FALSE;
sk24 := FALSE;
sk25 := FALSE;
sk26 := FALSE;
sk27 := FALSE;
sk28 := FALSE;
sk29 := FALSE;
sk30 := FALSE;
sk31 := FALSE;
sk32 := FALSE;
sk33 := FALSE;]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="Fahrauftrag">
      <LineId Id="1741" Count="0" />
      <LineId Id="1863" Count="0" />
      <LineId Id="2122" Count="0" />
      <LineId Id="2372" Count="0" />
      <LineId Id="1671" Count="0" />
      <LineId Id="1471" Count="0" />
      <LineId Id="2005" Count="2" />
      <LineId Id="2503" Count="1" />
      <LineId Id="2008" Count="1" />
      <LineId Id="2179" Count="0" />
      <LineId Id="1999" Count="0" />
      <LineId Id="2180" Count="1" />
      <LineId Id="2000" Count="1" />
      <LineId Id="2124" Count="0" />
      <LineId Id="2070" Count="0" />
      <LineId Id="2014" Count="0" />
      <LineId Id="2003" Count="1" />
      <LineId Id="2010" Count="1" />
      <LineId Id="1998" Count="0" />
      <LineId Id="2066" Count="0" />
      <LineId Id="999" Count="2" />
      <LineId Id="1003" Count="0" />
      <LineId Id="1002" Count="0" />
      <LineId Id="2069" Count="0" />
      <LineId Id="1321" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="406" Count="0" />
      <LineId Id="191" Count="0" />
      <LineId Id="1535" Count="0" />
      <LineId Id="195" Count="0" />
      <LineId Id="192" Count="0" />
      <LineId Id="194" Count="0" />
      <LineId Id="400" Count="0" />
      <LineId Id="1369" Count="0" />
      <LineId Id="193" Count="0" />
      <LineId Id="1360" Count="0" />
      <LineId Id="663" Count="0" />
      <LineId Id="662" Count="0" />
      <LineId Id="796" Count="1" />
      <LineId Id="6" Count="0" />
      <LineId Id="89" Count="1" />
      <LineId Id="1453" Count="0" />
      <LineId Id="92" Count="1" />
      <LineId Id="427" Count="0" />
      <LineId Id="377" Count="0" />
      <LineId Id="422" Count="4" />
      <LineId Id="91" Count="0" />
      <LineId Id="983" Count="0" />
      <LineId Id="982" Count="0" />
      <LineId Id="1087" Count="1" />
      <LineId Id="2482" Count="1" />
      <LineId Id="2485" Count="1" />
      <LineId Id="2484" Count="0" />
      <LineId Id="987" Count="2" />
      <LineId Id="985" Count="0" />
      <LineId Id="527" Count="0" />
      <LineId Id="526" Count="0" />
      <LineId Id="605" Count="0" />
      <LineId Id="1365" Count="0" />
      <LineId Id="2247" Count="0" />
      <LineId Id="2505" Count="0" />
      <LineId Id="531" Count="1" />
      <LineId Id="557" Count="2" />
      <LineId Id="556" Count="0" />
      <LineId Id="534" Count="0" />
      <LineId Id="549" Count="1" />
      <LineId Id="552" Count="1" />
      <LineId Id="555" Count="0" />
      <LineId Id="530" Count="0" />
      <LineId Id="288" Count="0" />
      <LineId Id="249" Count="0" />
      <LineId Id="289" Count="0" />
      <LineId Id="110" Count="0" />
      <LineId Id="251" Count="0" />
      <LineId Id="250" Count="0" />
      <LineId Id="254" Count="0" />
      <LineId Id="252" Count="0" />
      <LineId Id="263" Count="4" />
      <LineId Id="262" Count="0" />
      <LineId Id="253" Count="0" />
      <LineId Id="65" Count="0" />
      <LineId Id="111" Count="1" />
      <LineId Id="261" Count="0" />
      <LineId Id="114" Count="0" />
      <LineId Id="113" Count="0" />
      <LineId Id="68" Count="0" />
      <LineId Id="66" Count="0" />
      <LineId Id="120" Count="0" />
      <LineId Id="1538" Count="0" />
      <LineId Id="268" Count="0" />
      <LineId Id="125" Count="0" />
      <LineId Id="2512" Count="0" />
      <LineId Id="460" Count="0" />
      <LineId Id="2514" Count="0" />
      <LineId Id="2513" Count="0" />
      <LineId Id="1006" Count="1" />
      <LineId Id="124" Count="0" />
      <LineId Id="1009" Count="0" />
      <LineId Id="2373" Count="0" />
      <LineId Id="1005" Count="0" />
      <LineId Id="126" Count="1" />
      <LineId Id="1596" Count="1" />
      <LineId Id="354" Count="1" />
      <LineId Id="1010" Count="0" />
      <LineId Id="1019" Count="0" />
      <LineId Id="1322" Count="0" />
      <LineId Id="2186" Count="1" />
      <LineId Id="1015" Count="0" />
      <LineId Id="2189" Count="1" />
      <LineId Id="2188" Count="0" />
      <LineId Id="1016" Count="1" />
      <LineId Id="1013" Count="0" />
      <LineId Id="1011" Count="0" />
      <LineId Id="122" Count="0" />
      <LineId Id="463" Count="0" />
      <LineId Id="290" Count="0" />
      <LineId Id="269" Count="0" />
      <LineId Id="291" Count="0" />
      <LineId Id="270" Count="13" />
      <LineId Id="286" Count="0" />
      <LineId Id="2316" Count="0" />
      <LineId Id="69" Count="0" />
      <LineId Id="133" Count="0" />
      <LineId Id="70" Count="0" />
      <LineId Id="134" Count="1" />
      <LineId Id="1539" Count="0" />
      <LineId Id="350" Count="0" />
      <LineId Id="2318" Count="0" />
      <LineId Id="137" Count="1" />
      <LineId Id="136" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="37" Count="0" />
      <LineId Id="139" Count="1" />
      <LineId Id="1454" Count="0" />
      <LineId Id="204" Count="0" />
      <LineId Id="2191" Count="0" />
      <LineId Id="563" Count="0" />
      <LineId Id="565" Count="2" />
      <LineId Id="1099" Count="0" />
      <LineId Id="1244" Count="0" />
      <LineId Id="1094" Count="0" />
      <LineId Id="568" Count="0" />
      <LineId Id="1095" Count="2" />
      <LineId Id="141" Count="0" />
      <LineId Id="992" Count="1" />
      <LineId Id="1091" Count="1" />
      <LineId Id="2487" Count="1" />
      <LineId Id="2490" Count="1" />
      <LineId Id="2489" Count="0" />
      <LineId Id="2427" Count="0" />
      <LineId Id="996" Count="1" />
      <LineId Id="1104" Count="0" />
      <LineId Id="1106" Count="1" />
      <LineId Id="1105" Count="0" />
      <LineId Id="1243" Count="0" />
      <LineId Id="998" Count="0" />
      <LineId Id="991" Count="0" />
      <LineId Id="608" Count="1" />
      <LineId Id="611" Count="0" />
      <LineId Id="1364" Count="0" />
      <LineId Id="2248" Count="0" />
      <LineId Id="2506" Count="0" />
      <LineId Id="612" Count="8" />
      <LineId Id="622" Count="2" />
      <LineId Id="607" Count="0" />
      <LineId Id="292" Count="0" />
      <LineId Id="72" Count="0" />
      <LineId Id="293" Count="0" />
      <LineId Id="298" Count="14" />
      <LineId Id="2194" Count="0" />
      <LineId Id="399" Count="0" />
      <LineId Id="313" Count="1" />
      <LineId Id="40" Count="0" />
      <LineId Id="315" Count="0" />
      <LineId Id="76" Count="0" />
      <LineId Id="150" Count="1" />
      <LineId Id="1540" Count="0" />
      <LineId Id="351" Count="0" />
      <LineId Id="2195" Count="0" />
      <LineId Id="152" Count="1" />
      <LineId Id="149" Count="0" />
      <LineId Id="155" Count="0" />
      <LineId Id="51" Count="0" />
      <LineId Id="161" Count="1" />
      <LineId Id="1542" Count="0" />
      <LineId Id="205" Count="0" />
      <LineId Id="163" Count="0" />
      <LineId Id="1598" Count="1" />
      <LineId Id="358" Count="1" />
      <LineId Id="156" Count="0" />
      <LineId Id="294" Count="0" />
      <LineId Id="79" Count="0" />
      <LineId Id="295" Count="0" />
      <LineId Id="316" Count="9" />
      <LineId Id="2428" Count="0" />
      <LineId Id="326" Count="3" />
      <LineId Id="402" Count="0" />
      <LineId Id="2192" Count="0" />
      <LineId Id="404" Count="0" />
      <LineId Id="168" Count="0" />
      <LineId Id="170" Count="0" />
      <LineId Id="78" Count="0" />
      <LineId Id="172" Count="1" />
      <LineId Id="2193" Count="0" />
      <LineId Id="1455" Count="0" />
      <LineId Id="352" Count="0" />
      <LineId Id="175" Count="0" />
      <LineId Id="177" Count="0" />
      <LineId Id="176" Count="0" />
      <LineId Id="178" Count="0" />
      <LineId Id="174" Count="0" />
      <LineId Id="943" Count="2" />
      <LineId Id="1100" Count="3" />
      <LineId Id="946" Count="0" />
      <LineId Id="1242" Count="0" />
      <LineId Id="947" Count="0" />
      <LineId Id="171" Count="0" />
      <LineId Id="187" Count="0" />
      <LineId Id="63" Count="0" />
      <LineId Id="657" Count="0" />
      <LineId Id="656" Count="0" />
      <LineId Id="794" Count="1" />
      <LineId Id="658" Count="0" />
      <LineId Id="730" Count="0" />
      <LineId Id="1456" Count="0" />
      <LineId Id="731" Count="2" />
      <LineId Id="1246" Count="0" />
      <LineId Id="735" Count="1" />
      <LineId Id="1247" Count="1" />
      <LineId Id="737" Count="0" />
      <LineId Id="1197" Count="0" />
      <LineId Id="1199" Count="1" />
      <LineId Id="1202" Count="1" />
      <LineId Id="2492" Count="1" />
      <LineId Id="2495" Count="1" />
      <LineId Id="2494" Count="0" />
      <LineId Id="1206" Count="3" />
      <LineId Id="742" Count="1" />
      <LineId Id="745" Count="0" />
      <LineId Id="1366" Count="0" />
      <LineId Id="2249" Count="0" />
      <LineId Id="2507" Count="0" />
      <LineId Id="746" Count="8" />
      <LineId Id="756" Count="1" />
      <LineId Id="1288" Count="0" />
      <LineId Id="758" Count="8" />
      <LineId Id="768" Count="17" />
      <LineId Id="1543" Count="0" />
      <LineId Id="786" Count="0" />
      <LineId Id="1287" Count="0" />
      <LineId Id="789" Count="1" />
      <LineId Id="729" Count="0" />
      <LineId Id="800" Count="0" />
      <LineId Id="799" Count="0" />
      <LineId Id="801" Count="0" />
      <LineId Id="1537" Count="0" />
      <LineId Id="804" Count="0" />
      <LineId Id="2518" Count="3" />
      <LineId Id="2527" Count="1" />
      <LineId Id="2526" Count="0" />
      <LineId Id="2515" Count="0" />
      <LineId Id="2517" Count="0" />
      <LineId Id="2529" Count="14" />
      <LineId Id="2546" Count="9" />
      <LineId Id="870" Count="4" />
      <LineId Id="876" Count="1" />
      <LineId Id="802" Count="0" />
      <LineId Id="896" Count="2" />
      <LineId Id="1271" Count="1" />
      <LineId Id="1274" Count="1" />
      <LineId Id="2497" Count="1" />
      <LineId Id="2500" Count="1" />
      <LineId Id="2499" Count="0" />
      <LineId Id="1278" Count="7" />
      <LineId Id="899" Count="0" />
      <LineId Id="1286" Count="0" />
      <LineId Id="901" Count="1" />
      <LineId Id="1367" Count="0" />
      <LineId Id="2250" Count="0" />
      <LineId Id="2508" Count="0" />
      <LineId Id="903" Count="7" />
      <LineId Id="1923" Count="0" />
      <LineId Id="911" Count="22" />
      <LineId Id="1735" Count="0" />
      <LineId Id="1729" Count="0" />
      <LineId Id="934" Count="0" />
      <LineId Id="1800" Count="0" />
      <LineId Id="1799" Count="0" />
      <LineId Id="1803" Count="1" />
      <LineId Id="1801" Count="1" />
      <LineId Id="2183" Count="0" />
      <LineId Id="2182" Count="0" />
      <LineId Id="2184" Count="1" />
      <LineId Id="935" Count="3" />
      <LineId Id="1536" Count="0" />
      <LineId Id="939" Count="3" />
      <LineId Id="2068" Count="0" />
      <LineId Id="900" Count="0" />
      <LineId Id="1407" Count="0" />
      <LineId Id="2067" Count="0" />
      <LineId Id="1408" Count="0" />
      <LineId Id="1857" Count="0" />
      <LineId Id="1859" Count="0" />
      <LineId Id="1410" Count="0" />
      <LineId Id="1866" Count="4" />
      <LineId Id="2178" Count="0" />
      <LineId Id="1937" Count="2" />
      <LineId Id="1944" Count="0" />
      <LineId Id="1936" Count="0" />
      <LineId Id="1933" Count="0" />
      <LineId Id="2126" Count="0" />
      <LineId Id="1946" Count="1" />
      <LineId Id="1865" Count="0" />
      <LineId Id="2252" Count="0" />
      <LineId Id="2251" Count="0" />
      <LineId Id="2260" Count="1" />
      <LineId Id="2263" Count="0" />
      <LineId Id="2254" Count="0" />
    </LineIds>
    <LineIds Name="Fahrauftrag.CameraDataSaved">
      <LineId Id="18" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="13" Count="0" />
    </LineIds>
    <LineIds Name="Fahrauftrag.CollisionsSolution_new">
      <LineId Id="15" Count="12" />
      <LineId Id="152" Count="0" />
      <LineId Id="28" Count="13" />
      <LineId Id="153" Count="1" />
      <LineId Id="156" Count="0" />
      <LineId Id="155" Count="0" />
      <LineId Id="42" Count="8" />
      <LineId Id="162" Count="0" />
      <LineId Id="51" Count="5" />
      <LineId Id="255" Count="1" />
      <LineId Id="57" Count="2" />
      <LineId Id="163" Count="0" />
      <LineId Id="60" Count="4" />
      <LineId Id="164" Count="0" />
      <LineId Id="65" Count="3" />
      <LineId Id="165" Count="0" />
      <LineId Id="69" Count="0" />
      <LineId Id="166" Count="0" />
      <LineId Id="169" Count="0" />
      <LineId Id="167" Count="0" />
      <LineId Id="174" Count="0" />
      <LineId Id="168" Count="0" />
      <LineId Id="70" Count="0" />
      <LineId Id="258" Count="2" />
      <LineId Id="176" Count="0" />
      <LineId Id="171" Count="0" />
      <LineId Id="173" Count="0" />
      <LineId Id="172" Count="0" />
      <LineId Id="71" Count="4" />
      <LineId Id="175" Count="0" />
      <LineId Id="76" Count="9" />
      <LineId Id="177" Count="0" />
      <LineId Id="86" Count="1" />
      <LineId Id="194" Count="0" />
      <LineId Id="218" Count="0" />
      <LineId Id="226" Count="0" />
      <LineId Id="233" Count="5" />
      <LineId Id="195" Count="0" />
      <LineId Id="219" Count="0" />
      <LineId Id="192" Count="0" />
      <LineId Id="221" Count="0" />
      <LineId Id="228" Count="2" />
      <LineId Id="222" Count="0" />
      <LineId Id="257" Count="0" />
      <LineId Id="224" Count="0" />
      <LineId Id="227" Count="0" />
      <LineId Id="223" Count="0" />
      <LineId Id="225" Count="0" />
      <LineId Id="231" Count="1" />
      <LineId Id="220" Count="0" />
      <LineId Id="193" Count="0" />
      <LineId Id="191" Count="0" />
      <LineId Id="88" Count="4" />
      <LineId Id="196" Count="0" />
      <LineId Id="93" Count="2" />
      <LineId Id="197" Count="0" />
      <LineId Id="96" Count="0" />
      <LineId Id="198" Count="0" />
      <LineId Id="97" Count="7" />
      <LineId Id="199" Count="0" />
      <LineId Id="105" Count="8" />
      <LineId Id="245" Count="1" />
      <LineId Id="248" Count="0" />
      <LineId Id="247" Count="0" />
      <LineId Id="114" Count="11" />
      <LineId Id="200" Count="0" />
      <LineId Id="126" Count="0" />
      <LineId Id="201" Count="0" />
      <LineId Id="127" Count="7" />
      <LineId Id="205" Count="0" />
      <LineId Id="204" Count="0" />
      <LineId Id="206" Count="1" />
      <LineId Id="202" Count="0" />
      <LineId Id="135" Count="2" />
      <LineId Id="203" Count="0" />
      <LineId Id="138" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="Fahrauftrag.continueAfterCollision">
      <LineId Id="6" Count="3" />
      <LineId Id="163" Count="1" />
      <LineId Id="17" Count="1" />
      <LineId Id="173" Count="0" />
      <LineId Id="28" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="148" Count="0" />
      <LineId Id="151" Count="0" />
      <LineId Id="149" Count="0" />
      <LineId Id="83" Count="21" />
      <LineId Id="107" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="51" Count="0" />
      <LineId Id="30" Count="4" />
      <LineId Id="108" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="152" Count="1" />
      <LineId Id="109" Count="0" />
      <LineId Id="154" Count="0" />
      <LineId Id="111" Count="28" />
      <LineId Id="110" Count="0" />
      <LineId Id="140" Count="0" />
      <LineId Id="12" Count="3" />
      <LineId Id="26" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="Fahrauftrag.doReset">
      <LineId Id="73" Count="1" />
      <LineId Id="77" Count="5" />
      <LineId Id="84" Count="0" />
      <LineId Id="86" Count="0" />
      <LineId Id="76" Count="0" />
      <LineId Id="92" Count="0" />
      <LineId Id="87" Count="0" />
      <LineId Id="75" Count="0" />
      <LineId Id="72" Count="0" />
      <LineId Id="7" Count="36" />
      <LineId Id="45" Count="0" />
      <LineId Id="68" Count="0" />
      <LineId Id="55" Count="0" />
      <LineId Id="50" Count="0" />
    </LineIds>
    <LineIds Name="Fahrauftrag.drivingBack">
      <LineId Id="7" Count="0" />
      <LineId Id="115" Count="0" />
      <LineId Id="154" Count="2" />
      <LineId Id="158" Count="0" />
      <LineId Id="153" Count="0" />
      <LineId Id="152" Count="0" />
      <LineId Id="118" Count="0" />
      <LineId Id="116" Count="0" />
      <LineId Id="119" Count="0" />
      <LineId Id="121" Count="0" />
      <LineId Id="120" Count="0" />
      <LineId Id="122" Count="0" />
      <LineId Id="80" Count="16" />
      <LineId Id="111" Count="3" />
      <LineId Id="97" Count="5" />
      <LineId Id="123" Count="0" />
      <LineId Id="103" Count="4" />
      <LineId Id="8" Count="0" />
      <LineId Id="124" Count="1" />
      <LineId Id="127" Count="0" />
      <LineId Id="79" Count="0" />
      <LineId Id="6" Count="0" />
      <LineId Id="109" Count="0" />
      <LineId Id="10" Count="2" />
      <LineId Id="14" Count="4" />
      <LineId Id="20" Count="1" />
      <LineId Id="30" Count="1" />
      <LineId Id="139" Count="0" />
      <LineId Id="41" Count="0" />
      <LineId Id="110" Count="0" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="Fahrauftrag.errorTest">
      <LineId Id="12" Count="0" />
      <LineId Id="6" Count="5" />
      <LineId Id="63" Count="0" />
      <LineId Id="33" Count="1" />
      <LineId Id="13" Count="0" />
      <LineId Id="15" Count="1" />
      <LineId Id="18" Count="2" />
      <LineId Id="64" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="39" Count="1" />
      <LineId Id="43" Count="1" />
      <LineId Id="42" Count="0" />
      <LineId Id="65" Count="0" />
      <LineId Id="59" Count="0" />
      <LineId Id="41" Count="0" />
      <LineId Id="50" Count="0" />
    </LineIds>
    <LineIds Name="Fahrauftrag.findNodesToRemove">
      <LineId Id="118" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="113" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="116" Count="0" />
      <LineId Id="18" Count="73" />
      <LineId Id="128" Count="0" />
      <LineId Id="92" Count="3" />
      <LineId Id="130" Count="0" />
      <LineId Id="132" Count="2" />
      <LineId Id="131" Count="0" />
      <LineId Id="129" Count="0" />
      <LineId Id="96" Count="5" />
      <LineId Id="5" Count="0" />
      <LineId Id="117" Count="0" />
      <LineId Id="114" Count="1" />
    </LineIds>
    <LineIds Name="Fahrauftrag.otherRoboInfo">
      <LineId Id="83" Count="0" />
      <LineId Id="82" Count="0" />
      <LineId Id="69" Count="0" />
      <LineId Id="68" Count="0" />
      <LineId Id="66" Count="0" />
      <LineId Id="6" Count="5" />
      <LineId Id="70" Count="1" />
      <LineId Id="12" Count="6" />
      <LineId Id="40" Count="3" />
      <LineId Id="19" Count="2" />
      <LineId Id="44" Count="3" />
      <LineId Id="22" Count="1" />
      <LineId Id="48" Count="1" />
      <LineId Id="24" Count="4" />
      <LineId Id="93" Count="0" />
      <LineId Id="91" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="92" Count="0" />
      <LineId Id="60" Count="0" />
      <LineId Id="31" Count="1" />
      <LineId Id="94" Count="0" />
      <LineId Id="52" Count="1" />
      <LineId Id="5" Count="0" />
      <LineId Id="74" Count="2" />
      <LineId Id="72" Count="1" />
    </LineIds>
    <LineIds Name="Fahrauftrag.removeAllToken">
      <LineId Id="6" Count="37" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="Fahrauftrag.resetCollision">
      <LineId Id="14" Count="1" />
      <LineId Id="6" Count="4" />
      <LineId Id="49" Count="3" />
      <LineId Id="5" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="22" Count="8" />
      <LineId Id="32" Count="7" />
      <LineId Id="43" Count="1" />
    </LineIds>
  </POU>
</TcPlcObject>