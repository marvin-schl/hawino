<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="KalmanObserverST" Id="{7db7eead-d75a-4327-8490-42b5b4fd681c}" SpecialFunc="None">
    <Declaration><![CDATA[//SimpleObserver:
//Implements a simple observer which assumes the camera position is the true position of the robot whenever camera data arrives. Between new cam data
//odometry is used to correct the robots position. The cameras latency is also considered by correcting the arrived camera data with odometry based correction
//within the time interval of the latency. The observer is implemented in Simulink and is linked within this FB to abstract the implementation of the observer from the
//main control algorithm. Inside the Simulink model all coordinates are considered as world coordinates, following that the transformation of between robot and world coordinates 
//is implemented in ST.
FUNCTION_BLOCK KalmanObserverST
VAR_INPUT
	xCameraPose:	RobotPoseSimple;
	xVxRobot: 		LREAL;
	xVyRobot: 		LREAL;
	xOmegaRobot: 	LREAL;
	theta:			LREAL; //theta for I/O Lineraztion only explicitly Input for FF-Linearization
END_VAR

VAR_OUTPUT
	yObserverdPose: 	RobotPoseSimple;
END_VAR

VAR
	newCamDataArrived: BOOL;
	camDataOld, observerError, observedPosition, vWorld: RobotPoseSimple;
	pulseGenerator: TP;
	
	delayedCycles		AT%Q* 	: INT	:= 80;	//Camdelay 160ms / Cycletyme 2ms
	delayedPosition: ARRAY [0..140] OF RobotPoseSimple;
	
	
	K : ARRAY [0..2,0..2] OF LREAL 		:= [18, 0 ,0,
									  		0, 18, 0,
									  		0, 0, 18];
											
	P, H, TEMP : ARRAY [0..2,0..2] OF LREAL;

	(*Q : ARRAY [0..2,0..2] OF LREAL 		:=[9.3047,    0.4415,   -0.0036,
    									   0.4415,    26.0708,   -0.0078,
   										  -0.0036,   -0.0078,    0.0007];*)
										  
	Q : ARRAY [0..2,0..2] OF LREAL 		:=[0.0145,    0.2583,   -0.1632,
    									   0.1352,    0.0092,    0.2404,
   										   -0.4028,   0.1352,    0.0001];
											  
	(*RMat : ARRAY [0..2, 0..2] OF LREAL 	:= [0.00127820524383046,    -0.00144745069148629,    1.57202639633006E-06,
											-0.00144745069148629,    0.0142936660651043,      -2.43008878392535E-05,
											1.57202639633006E-06,    -2.43008878392535E-05,	  2.50703907504212E-07]; *)
											
	RMat : ARRAY [0..2, 0..2] OF LREAL 	:= [0.0291,		0.6199,		-0.5602,
											0.6455,		0.0307,      0.2979,
											-0.0226,    -0.0317,	 0.0098];
											
	C : ARRAY [0..2,0..2] OF LREAL 		:=[1, 0, 0,
    									   0, 1, 0,
   										   0, 0, 1];
	// TEST
	//systime : NT_GetTime;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[//transform roboter velocities into world velocities and pass them to Simulink
Robot2World( 
	vx_robot 	:= xVxRobot,
	vy_robot 	:= xVyRobot,
	omega_robot := xOmegaRobot,
	theta		:= yObserverdPose.theta,
	vx_world 	=> vWorld.x,
	vy_world  	=> vWorld.y,
	omega_world => vWorld.theta);
	
CheckForNewCameraData();	//Schreibt direkt in Variable  "newCamDataArrived"

//systime(START:=newCamDataArrived);	// TEST

delayPosition();

//if cam data arrived correct
IF newCamDataArrived THEN
	TEMP := AddMat3(P,RMat);
	TEMP := MatInv3(TEMP);
	H := MatTimesMat(P, TEMP);
	//calculate observer error
	observerError := SubtractRPS(xCameraPose,delayedPosition[delayedCycles]);
	//do the feedback correction
	observedPosition := AddRPS(observedPosition, ScaleRPS(c := Var_HAWIno.CONTROLLER_CYCLE_TIME, AddRPS(vWorld, MatTimesRPS(H, observerError))));
	
	TEMP := MatTimesMat(H, C);
	TEMP := MatTimesMat(TEMP, P);
	P := SubstractMat3(P, TEMP);
ELSE
	observedPosition := AddRPS(observedPosition, ScaleRPS(c := Var_HAWIno.CONTROLLER_CYCLE_TIME, vWorld));
	P := AddMat3(P, Q);
END_IF


//set Outputs
yObserverdPose 	:= observedPosition;
camDataOld 		:= xCameraPose;
]]></ST>
    </Implementation>
    <Method Name="checkForNewCameraData" Id="{d7b79a97-aba5-4db5-aeac-59a0c2b4be86}">
      <Declaration><![CDATA[METHOD checkForNewCameraData : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[newCamDataArrived := (camDataOld.x <> xCameraPose.x OR camDataOld.y <> xCameraPose.y OR camDataOld.theta <> xCameraPose.theta) //cahnge in one of the positions
					 AND xCameraPose.x <> 0 AND xCameraPose.y <> 0;		//valid data
	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="delayPosition" Id="{016b76e0-836d-4268-9f94-66f08373c96c}">
      <Declaration><![CDATA[METHOD PRIVATE delayPosition : BOOL
VAR_INPUT
END_VAR
VAR
	i: INT := 0;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR i := 0 TO delayedCycles-1 DO
	delayedPosition[i+1] := delayedPosition[i];
END_FOR
delayedPosition[0] := observedPosition;]]></ST>
      </Implementation>
    </Method>
    <Method Name="reset" Id="{e0675e18-d699-40d3-8169-07aa4f6de232}">
      <Declaration><![CDATA[METHOD reset : BOOL
VAR_INPUT
END_VAR
VAR
	
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[observedPosition := xCameraPose;]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="KalmanObserverST">
      <LineId Id="568" Count="17" />
      <LineId Id="608" Count="0" />
      <LineId Id="626" Count="0" />
      <LineId Id="607" Count="0" />
      <LineId Id="586" Count="3" />
      <LineId Id="628" Count="2" />
      <LineId Id="627" Count="0" />
      <LineId Id="590" Count="1" />
      <LineId Id="599" Count="0" />
      <LineId Id="593" Count="5" />
      <LineId Id="14" Count="0" />
    </LineIds>
    <LineIds Name="KalmanObserverST.checkForNewCameraData">
      <LineId Id="5" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="7" Count="1" />
    </LineIds>
    <LineIds Name="KalmanObserverST.delayPosition">
      <LineId Id="5" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="11" Count="0" />
    </LineIds>
    <LineIds Name="KalmanObserverST.reset">
      <LineId Id="13" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>