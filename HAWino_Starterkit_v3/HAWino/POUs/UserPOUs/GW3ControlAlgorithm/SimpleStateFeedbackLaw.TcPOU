<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="SimpleStateFeedbackLaw" Id="{b6b00111-b334-4516-8a6e-fa6dcb5c765f}" SpecialFunc="None">
    <Declaration><![CDATA[(*SimpleStateFeedbackLaw:
Implements a simple state feedback law with a 3x3 control gain matrix 'K', 
a translation speed limit 'vtrans_max' (x- and y-axis) and a rotational speed 
limit 'vrot_max'.
*)
FUNCTION_BLOCK SimpleStateFeedbackLaw
VAR_INPUT
	xRobotPose: 		RobotPoseSimple; 				//current pose
	xRobotPoseRef: 		RobotPoseSimple; 				//reference pose
	enable:				BOOL 			:= FALSE;
END_VAR

VAR_OUTPUT
	//control outputs
	vXrobot:			LREAL;
	vYrobot:			LREAL;
	omegaRobot:			LREAL;
	reachedReference:	BOOL;
END_VAR

VAR
	//static control parameters
	K: ARRAY [0..2,0..2] OF LREAL := [3,0,0,
									  0,3,0,
									  0,0,3];
	poseError: RobotPoseSimple;
	vtrans_max: LREAL := 934; //vY,vY
	vrot_max: LREAL   := 1.57; //vTheta
	u: ARRAY[0..2] OF LREAL;
	i: INT;
	accuracyXY: LREAL := 2;
	accuracyTheta: LREAL := 0.01;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[//1.) calculate pose errors
poseError.x 	:= xRobotPoseRef.x 		- xRobotPose.x;
poseError.y 	:= xRobotPoseRef.y 		- xRobotPose.y;
poseError.theta := xRobotPoseRef.theta 	- xRobotPose.theta;

//IF poseError.theta > pi THEN
//	poseError.theta := -2*pi+poseError.theta;
//ELSIF poseError.theta < -pi THEN
//	poseError.theta := 2*pi+poseError.theta;
//END_IF
	

reachedReference := (ABS(poseError.x) < accuracyXY) AND (ABS(poseError.y) < accuracyXY) AND (ABS(poseError.theta) < accuracyTheta);



//2.) apply gain on errors
FOR i := 0 TO 2 DO
	u[i] := K[0,i] * poseError.x + K[1,i] * poseError.y + K[2,i] * poseError.theta;
END_FOR;

//3.) apply saturation
FOR i := 0 TO 1 DO
	IF u[i] > vtrans_max THEN
		u[i] := vtrans_max;
	ELSIF u[i] < -vtrans_max THEN
		u[i] := -vtrans_max;
	END_IF
END_FOR

IF u[2] > vrot_max THEN
	u[2] := vrot_max;
ELSIF u[2] < -vrot_max THEN
	u[2] := -vrot_max;
END_IF

//4.) set control outputs
IF enable THEN
	vXrobot 	:= u[0];
	vYrobot 	:= u[1];
	omegaRobot	:= u[2];
ELSE
	vXrobot 	:= 0;
	vYrobot 	:= 0;
	omegaRobot  := 0;
END_IF


]]></ST>
    </Implementation>
    <Method Name="reset" Id="{abf3cfa0-3136-4152-8add-0d4168a8fd70}">
      <Declaration><![CDATA[METHOD reset : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[reachedReference := FALSE;]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="SimpleStateFeedbackLaw">
      <LineId Id="9" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="198" Count="0" />
      <LineId Id="197" Count="0" />
      <LineId Id="199" Count="1" />
      <LineId Id="203" Count="0" />
      <LineId Id="202" Count="0" />
      <LineId Id="201" Count="0" />
      <LineId Id="155" Count="1" />
      <LineId Id="162" Count="1" />
      <LineId Id="37" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="41" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="40" Count="0" />
      <LineId Id="119" Count="0" />
      <LineId Id="100" Count="0" />
      <LineId Id="99" Count="0" />
      <LineId Id="101" Count="0" />
      <LineId Id="103" Count="0" />
      <LineId Id="105" Count="1" />
      <LineId Id="104" Count="0" />
      <LineId Id="102" Count="0" />
      <LineId Id="110" Count="4" />
      <LineId Id="109" Count="0" />
      <LineId Id="43" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="303" Count="0" />
      <LineId Id="74" Count="1" />
      <LineId Id="72" Count="0" />
      <LineId Id="305" Count="3" />
      <LineId Id="237" Count="0" />
      <LineId Id="73" Count="0" />
      <LineId Id="154" Count="0" />
      <LineId Id="46" Count="0" />
    </LineIds>
    <LineIds Name="SimpleStateFeedbackLaw.reset">
      <LineId Id="5" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>