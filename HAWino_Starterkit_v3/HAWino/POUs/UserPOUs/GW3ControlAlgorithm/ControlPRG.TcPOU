<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="ControlPRG" Id="{012ed989-ad00-4074-8a95-3f6b38ed2b93}" SpecialFunc="None">
    <Declaration><![CDATA[//Tracking controller:
// Main handling of the control algorithm
// implements a state machine with states: init, idle, calcTrajectory, ready, driving
// links the different components of the control algorithm: control law, observer, trajectory, robot, camera... => Maybe more needed later e.g. filter 
// links to GW2 via the defined interface

PROGRAM ControlPRG
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR
	//declare objects
	kobserver		  : KalmanObserverST;
	collisionDetector : collisionDetector;
	controller		  : SimpleStateFeedbackLaw;			//Control law object
	trajectory		  : TimeOptimalTrajectory;			//Trajectory Object
	robot			  : Robot;							//link to physical I/O of roboter or simulation model of the roboter
	robotPoses 	 AT%I*: ARRAY [1..8] OF RobotPose;	    //input from camera
	
	state AT%Q*: ControllerState := ControllerState.init;//sets controller state
	
	CONTROL_ERROR_THRESH : LREAL := 5;
	
	FFLin: BOOL := ControlParameters.FeedForwardLinearization;
	thetaLin: LREAL;
	
	///////////////////////////////////////////////
	///////////// LINKS TO GW2  ///////////////////
	///////////////////////////////////////////////
	
	//inputs from GW2, uncomment and link when needed
	xBoEnable AT%I*: BOOL := FALSE;							// implemented, Freigabesignal für Fahrt, Roboter stoppt bei FALSE
	xBoReset  AT%I*: BOOL := FALSE;							// implemented, reset error state => idle
	waypointList AT%I*: ARRAY[0..100] OF RobotPoseSimple;	// implemented, Wegpunktliste mit Roboter-Posen in globalen Koordinaten (x, y, theta)
	newWaypointListAvailable AT%I*: BOOL := FALSE;			// implemented, Status-Bit zur Signalisierung einer neuen WP-Liste
	
	//outputs to GW2, uncomment and link when needed
	yBoArrivedAtDestination AT%Q*:	BOOL := FALSE;			// implemented, TRUE, wenn Ziel erreicht, Ziel entspricht letzten gültigen WP
	yUintWaypointIndex 	AT%Q*: INT  := 0;					// implemented, COUNTER zur Anzeige, des Indexes des nächstes WP
	yRPposition 		AT%Q*: RobotPoseSimple;				// implemented, aktuelle Roboterposition, für Simulationszwecke
	yVworldRef			AT%Q*: RobotPoseSimple;
	collision			AT%Q*: ARRAY [0..4] OF BOOL;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[//robot disabled by default
robot.enable			:= FALSE;

//outputs to GW2
yRPposition 			:= kobserver.yObserverdPose;
yUintWaypointIndex 		:= trajectory.WPLidx;
yVworldRef				:= controller.xRobotvelRef;
collision				:= collisionDetector.collisionDetected;

//call controller state machine
stateMachine();

//Select FF or FB linearization
IF FFLin = TRUE THEN
	thetaLin := trajectory.referencePose.theta;
ELSE
	thetaLin := kobserver.yObserverdPose.theta;		
END_IF

collisionDetector(
	rawRobotPoses 	:= robotPoses,
	observedPose 	:= kobserver.yObserverdPose,
	vX 		:= robot.vX,
	vY 		:= robot.vY);
//initilizing and linking of control algorithm individual components
//init observer
kobserver(xCameraPose 	:= shiftCamAngle(camData := robotPoses[Var_HAWIno.Robot_Number], path := trajectory.path),
		 //xCameraPose 	:= robotPoses[Var_HAWIno.Robot_Number],
		 xVxRobot    	:= robot.vX,						//link x-velocity with measured velocity
		 xVyRobot    	:= robot.vY,						//link y-velocity with measured velocity
		 xOmegaRobot    := robot.vTheta,
 		 //xVxToRobot		:= controller.vXrobot,
		 //xVyToRobot		:= controller.vYrobot,
		 //xOmegaToRobot	:= controller.omegaRobot,				//link theta-velocity with measured velocity
		 theta			:= thetaLin);	

						//Angle for IO-Lineariztion						 
//init controller and link to observer
controller(xRobotPose 		:= kobserver.yObserverdPose,			//pass controller the observerd roboter pose
		   xRobotPoseRef	:= trajectory.referencePose,
		   xRobotVelRef		:= trajectory.referenceVelocities,
		   enable			:= robot.enable);		//pass controller the reference position for the next cycle comming from the trajectory

//trajectory object
trajectory(
	drive 			:= robot.enable,
	currentPose 	:= kobserver.yObserverdPose,					//Current implementation needs observed pose for distance calculation, TODO: check if needed for final implemenation
	referencePose 	=> controller.xRobotPoseRef					//outputs reference pose to controller
);

//observer.xCameraPose 	:= shiftCamAngle(camData := robotPoses[Var_HAWIno.Robot_Number], path := trajectory.path);
//transform control inputs into robot coordinates and pass them to the robot
//pass enable signal to robot
World2Robot(
			vx_world := controller.vXrobot,						//controller outputs vXref in world coordinates
			vy_world := controller.vYrobot,						//controller outputs vYref in world coordinates
			omega_world := controller.omegaRobot,				//controller outputs vThetaRef in world coordinates
			theta := thetaLin,									//trajectory theta for I/O Lin => FB-Structure
			vx_robot => robot.vXref,							//vXref in robot coordinates are passed to robot as control output
			vy_robot => robot.vYref,							//vYref in robot coordinates are passed to robot as control output
			omega_robot => robot.vThetaRef						//vThetaref in robot coordinates are passed to robot as control output
);

// to do:
IF trajectory.finished AND controller.reachedReference THEN
	yBoArrivedAtDestination := TRUE;
END_IF

//needs to be called so that the velocities will be written to motor drives
robot(); 


]]></ST>
    </Implementation>
    <Method Name="calculateTrajectory" Id="{8f230d49-0c59-4087-8372-938452edcf61}">
      <Declaration><![CDATA[METHOD calculateTrajectory : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[trajectory.setWaypointList(waypointList);]]></ST>
      </Implementation>
    </Method>
    <Method Name="checkForFailure" Id="{446d1f43-1056-493b-9cf0-95787b7cd4d1}">
      <Declaration><![CDATA[METHOD checkForFailure : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[checkForFailure := robot.bumperGotTriggered OR trajectory.generationFailed;]]></ST>
      </Implementation>
    </Method>
    <Method Name="drive" Id="{d4cf0706-755e-4b45-b3e9-0b9f8575bd33}">
      <Declaration><![CDATA[METHOD drive : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[robot.enable := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="init" Id="{0d1b690b-7302-4509-955c-4b8bf838eebc}">
      <Declaration><![CDATA[METHOD init : BOOL
VAR_INPUT
END_VAR
VAR
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="reset" Id="{157a2148-99f8-44be-ab04-ad5b7071ba02}">
      <Declaration><![CDATA[METHOD reset : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[reset := trajectory.reset() AND controller.reset() AND kobserver.reset();]]></ST>
      </Implementation>
    </Method>
    <Method Name="stateMachine" Id="{b78dbbfe-fbe2-4845-ae04-710ba9036014}">
      <Declaration><![CDATA[METHOD stateMachine : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//control algorithms state machine
CASE state OF
	ControllerState.init:
		//initilize objects and link them
		init();
		//go into idle
		state := ControllerState.idle;
	
	ControllerState.idle:
		//if new waypointlist available reset trajectory and go into set trajectory state
		IF checkForFailure() THEN
			state := ControllerState.error;
		ELSIF newWaypointListAvailable THEN
			IF reset() THEN
				state := ControllerState.setTrajectory;
			END_IF
		END_IF
	
	ControllerState.setTrajectory:
		//got new trajectory so not anymore at destination
		yBoArrivedAtDestination := FALSE;
		//calculate trajectory
		trajectory.setWaypointList(waypointList);
			
		//go into calcTrajectory as soon as GW2 resets the new waypointlist flag to avoid looping through
		//ready --> setTrajectory --> calcTrajectory
		IF checkForFailure() THEN
			state := ControllerState.error;	
		ELSIF NOT newWaypointListAvailable AND trajectory.pathReady THEN
			state := ControllerState.calcTrajectory;
		END_IF
		
	 ControllerState.calcTrajectory:
		trajectory.generateTrajectory();
	 	IF checkForFailure() THEN
			state := ControllerState.error;
		ELSIF trajectory.ready THEN
			state := ControllerState.ready;
		END_IF
		
	
	ControllerState.ready:
		IF newWaypointListAvailable THEN
			//stop and calculate new trajectory
			IF reset() THEN
				state := ControllerState.setTrajectory;
			END_IF
		ELSIF xBoEnable THEN
			state := ControllerState.driving;
		END_IF
	
	ControllerState.driving:
		
		IF checkForFailure() THEN
			state := ControllerState.error;
		ELSIF newWaypointListAvailable THEN
			//stop and calculate new trajectory
			IF reset() THEN
				state := ControllerState.setTrajectory;
			END_IF
		ELSIF yBoArrivedAtDestination OR robot.sliderGotTriggered THEN
			yBoArrivedAtDestination := TRUE; //only relevant if transition is triggered through the slider
			//got back to idle and set arrived flag for GW2, method needed?
			IF reset() THEN
				state := ControllerState.idle;
			END_IF
		ELSIF xBoEnable THEN
			//do the driving
			drive();
		ELSE
			//if xBoEnable isn't set anymore go into ready and wait for it again
			state := ControllerState.ready;
		END_IF
		
	ControllerState.error:
		IF xBoReset THEN
			reset();
			state := ControllerState.idle;
		END_IF
END_CASE


]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="ControlPRG">
      <LineId Id="1147" Count="6" />
      <LineId Id="1770" Count="0" />
      <LineId Id="1870" Count="0" />
      <LineId Id="1769" Count="0" />
      <LineId Id="1768" Count="0" />
      <LineId Id="1771" Count="0" />
      <LineId Id="1773" Count="4" />
      <LineId Id="1772" Count="0" />
      <LineId Id="1820" Count="0" />
      <LineId Id="1456" Count="0" />
      <LineId Id="1864" Count="3" />
      <LineId Id="1227" Count="1" />
      <LineId Id="1552" Count="7" />
      <LineId Id="1550" Count="1" />
      <LineId Id="1549" Count="0" />
      <LineId Id="1246" Count="2" />
      <LineId Id="1506" Count="0" />
      <LineId Id="1249" Count="0" />
      <LineId Id="1463" Count="0" />
      <LineId Id="1458" Count="4" />
      <LineId Id="1250" Count="0" />
      <LineId Id="1652" Count="0" />
      <LineId Id="1464" Count="0" />
      <LineId Id="1251" Count="20" />
      <LineId Id="94" Count="0" />
    </LineIds>
    <LineIds Name="ControlPRG.calculateTrajectory">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="ControlPRG.checkForFailure">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="ControlPRG.drive">
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="ControlPRG.init">
      <LineId Id="26" Count="0" />
    </LineIds>
    <LineIds Name="ControlPRG.reset">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="ControlPRG.stateMachine">
      <LineId Id="6" Count="80" />
      <LineId Id="92" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>