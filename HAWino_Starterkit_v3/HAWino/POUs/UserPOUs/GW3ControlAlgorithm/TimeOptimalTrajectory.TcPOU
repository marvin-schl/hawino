<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="TimeOptimalTrajectory" Id="{c9d800de-1da9-4b82-a21b-c146282eb721}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK TimeOptimalTrajectory
VAR_INPUT
	currentPose			: RobotPoseSimple;
	drive				: BOOL 				:= FALSE;
END_VAR
VAR_OUTPUT
	finished			: BOOL 				:= FALSE;
	ready				: BOOL				:= FALSE;
	pathReady			: BOOL				:= FALSE;
	referencePose		: RobotPoseSimple;
	referenceVelocities	: RobotPoseSimple;
	WPLidx 				: INT 				:= 0;
	path				: Path;
END_VAR
VAR
	trajectoryPlanner	: TrajectoryPlanner;
	wayPointListRaw		: ARRAY [0..100] OF RobotPoseSimple;
	cnt					: INT 				:= 0;
	
    maxRadius		    : LREAL				:= 0.1;
	
	samplingTime		: LREAL				:= 0.05;
	
	maxVel				: LREAL				:= 0.6;
	maxAcc				: LREAL				:= 0.4;
	
	arcLengthSlow		: LREAL				:= 0.2;
	maxSlowVel			: LREAL				:= 0.08;
	
	maxRotVel			: LREAL				:= 100;
	maxRotAcc			: LREAL				:= 100;	
	
	thetaDZ				: LREAL				:= 0.2;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[ready := trajectoryPlanner.trajectoriesReady;
pathReady := path.ready;
IF cnt = LREAL_TO_INT(samplingTime/Var_HAWIno.CONTROLLER_CYCLE_TIME) AND NOT finished THEN
	WPLidx := WPLidx +1;
	cnt := 0;
END_IF

IF  trajectoryPlanner.posTrajectory[WPLidx].x = -1 AND trajectoryPlanner.posTrajectory[WPLidx].y = -1  AND trajectoryPlanner.posTrajectory[WPLidx].theta = -1 THEN
	finished := TRUE;
END_IF

IF drive AND NOT finished AND ready THEN
	referencePose := trajectoryPlanner.posTrajectory[WPLidx];
	referenceVelocities := trajectoryPlanner.velTrajectory[WPLidx];
	cnt := cnt +1;	
END_IF

]]></ST>
    </Implementation>
    <Method Name="generateTrajectory" Id="{3d1dbbe1-33ce-40a6-ae71-929ba959894c}">
      <Declaration><![CDATA[METHOD generateTrajectory : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[trajectoryPlanner.generateTrajectory();]]></ST>
      </Implementation>
    </Method>
    <Method Name="reset" Id="{a510e6d9-b061-4cba-a683-d76415bcb2be}">
      <Declaration><![CDATA[METHOD reset : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[WPLidx 			:= 0; 						//reset
finished 		:= FALSE;

path.reset();
trajectoryPlanner.reset();]]></ST>
      </Implementation>
    </Method>
    <Method Name="setRobotPose" Id="{612c742a-1fe7-4003-9836-d6bbc0467a35}">
      <Declaration><![CDATA[METHOD setRobotPose : RobotPoseSimple
VAR_INPUT
	newPose: RobotPoseSimple;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//not needed here ]]></ST>
      </Implementation>
    </Method>
    <Method Name="setWaypointList" Id="{e85e045f-80a3-4da6-9e39-79af30febaa9}">
      <Declaration><![CDATA[METHOD setWaypointList : ARRAY [0..100] OF RobotPoseSimple
VAR_INPUT
	newWayPointList	: ARRAY [0..100]  OF RobotPoseSimple;
END_VAR

VAR
	extendedWayPointList			:	ARRAY [0..101] OF RobotPoseSimple;
	i								: INT;
	maxInitialPoseError				: LREAL := 100;		// unit: mm
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Insert actual position as first waypoint if robot is too far away from first
IF (SQRT(EXPT(currentPose.x - newWayPointList[0].x, 2) + EXPT(currentPose.y - newWayPointList[0].y, 2)) > maxInitialPoseError) AND currentPose.x <> 0 AND currentPose.y <> 0 THEN
	// shift all elements +1 to right except the lat one (gets overwritten)
	FOR i := 100 TO 0 BY -1 DO
		extendedWayPointList[i + 1] := newWayPointList[i];
	END_FOR

	// insert actual pose as first waypoint
	extendedWayPointList[0] := currentPose;
ELSE
	// shift all elements +1 to right except the lat one (gets overwritten)
	FOR i := 0 TO 100 BY 1 DO
		extendedWayPointList[i] := newWayPointList[i];
	END_FOR
	
	extendedWayPointList[101].x := -1;
	extendedWayPointList[101].y := -1;
	extendedWayPointList[0].theta := currentPose.theta;
END_IF

path(waypointListRaw := extendedWayPointList, maxRadius := maxRadius, thetaDZ := thetaDZ);

IF path.ready THEN
	trajectoryPlanner(path := path, 
				  qAccMax := maxAcc, 
				  qVelMax := maxVel, 
				  thetaAccMax := maxRotAcc,
				  thetaVelMax := maxRotVel,
				  qVelMaxSlow := maxSlowVel,
				  arcLengthSlow := arcLengthSlow,
				  deltaT := samplingTime);
 END_IF
				  
]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="TimeOptimalTrajectory">
      <LineId Id="124" Count="0" />
      <LineId Id="279" Count="0" />
      <LineId Id="125" Count="6" />
      <LineId Id="133" Count="2" />
      <LineId Id="207" Count="0" />
      <LineId Id="138" Count="3" />
      <LineId Id="71" Count="0" />
    </LineIds>
    <LineIds Name="TimeOptimalTrajectory.generateTrajectory">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="TimeOptimalTrajectory.reset">
      <LineId Id="15" Count="1" />
      <LineId Id="21" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="7" Count="0" />
    </LineIds>
    <LineIds Name="TimeOptimalTrajectory.setRobotPose">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="TimeOptimalTrajectory.setWaypointList">
      <LineId Id="63" Count="1" />
      <LineId Id="68" Count="6" />
      <LineId Id="76" Count="0" />
      <LineId Id="79" Count="3" />
      <LineId Id="85" Count="1" />
      <LineId Id="88" Count="0" />
      <LineId Id="98" Count="0" />
      <LineId Id="67" Count="0" />
      <LineId Id="87" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="119" Count="0" />
      <LineId Id="118" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="34" Count="1" />
      <LineId Id="108" Count="0" />
      <LineId Id="120" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="24" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>