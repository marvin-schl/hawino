<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="BezierCurve" Id="{e77832cf-db41-4e37-bb04-ef53ff8726aa}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK BezierCurve EXTENDS Spline
VAR_INPUT
	x: 		ARRAY [0..2] OF LREAL;
	y: 		ARRAY [0..2] OF LREAL;
	radius: LREAL;
	deltaT: LREAL := 1E-3; //only for inital length calculation
END_VAR
VAR_OUTPUT
END_VAR
VAR
	prevWP, nextWP, controlPoint: RobotPoseSimple;
	a2, a1, a0, b2, b1, b0: LREAL;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[controlPoint.x 		:= x[1];
controlPoint.y 		:= y[1];
controlPoint.theta	:= -1; //not used

prevWP.x 		:= x[0];
prevWP.y 		:= y[1];
prevWP.theta	:= -1; //not used

nextWP.x		:= x[2];
nextWP.y		:= y[2];
nextWP.theta	:= -1; //not used

getStartEndPoint();
calculateCoefficients();
calculateLength();]]></ST>
    </Implementation>
    <Method Name="calculateCoefficients" Id="{358aa45f-b3d6-4b2a-8e91-98e0c973e800}">
      <Declaration><![CDATA[METHOD calculateCoefficients : RobotPoseSimple
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[a2 := (startPoint.x - 2*controlPoint.x + endPoint.x);
a1 := (2*controlPoint.x - 2*startPoint.x);
a0 := startPoint.x;

b2 := (startPoint.y - 2*controlPoint.y + endPoint.y);
b1 := (2*controlPoint.y - 2*startPoint.y);
b0 := startPoint.y;]]></ST>
      </Implementation>
    </Method>
    <Method Name="calculateLength" Id="{022b5e9a-942d-4cb5-a32c-ca554c58b677}">
      <Declaration><![CDATA[METHOD PROTECTED  calculateLength : LREAL
VAR_INPUT
END_VAR

VAR
	i : INT;
	t : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[calculateLength := 0;
FOR i := 0 TO LREAL_TO_INT(1/deltaT) DO
	t := i*deltaT;
	calculateLength := calculateLength + ds(t)*deltaT;
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="dds" Id="{6ecd8f45-18bb-42aa-9825-094704a154e9}">
      <Declaration><![CDATA[METHOD dds : LREAL
VAR_INPUT
	t, dsVal: LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[dds := (4*(EXPT(a2,2)+EXPT(b2,2))*t + 2*(a2*a1+b2*b1))/dsVal;]]></ST>
      </Implementation>
    </Method>
    <Method Name="diff" Id="{77e3fbe0-c097-4aa1-89b4-63503c3b240c}">
      <Declaration><![CDATA[METHOD  diff : RobotPoseSimple
VAR_INPUT
	arcLength: LREAL;
	order: INT := 1;
END_VAR
VAR
	t, dsVal, ddsVal: LREAL;
	dPos, ddPos: RobotPoseSimple;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[t 		:= normalize(arcLength);
dPos	:= diffNorm(t);
dsVal 		:= ds(t);
diff.theta := -1;

CASE order OF
	1 :
		diff.x := dPos.x/dsVal;
		diff.y := dPos.y/dsVal;
	2 :
	   //calculate first derivative
	   //inner derivative
		ddsVal := dds(t, dsVal);
		ddPos  := diff2Norm(t);
		
		//calculate second derivate, derivation NOT trivial
		diff.x := ddPos.x*EXPT(dsVal,-2) - dPos.x*EXPT(dsVal, -3) *ddsVal;
		diff.y := ddPos.y*EXPT(dsVal,-2) - dPos.y*EXPT(dsVal, -3) *ddsVal;

ELSE
	diff.x := -1.0;
	diff.y := -1.0;
	diff.theta := -1.0;
END_CASE;  ]]></ST>
      </Implementation>
    </Method>
    <Method Name="diff2Norm" Id="{a87920c3-fb56-49d7-9c6d-2ae3c7511236}">
      <Declaration><![CDATA[METHOD diff2Norm : RobotPoseSimple
VAR_INPUT
	t: LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[diff2Norm.x 		:= 2*a2;
diff2Norm.y 		:= 2*b2;
diff2Norm.theta		:= -1; //unused ]]></ST>
      </Implementation>
    </Method>
    <Method Name="diffNorm" Id="{3ae2bbde-fdd7-43b3-9729-e14fa3e8ab1e}">
      <Declaration><![CDATA[//return value isnt a euclidian pose anymore, 
//it represents the first order derivate of the Bezier Curve after t at input value of t
METHOD diffNorm : RobotPoseSimple 
VAR_INPUT
	t: LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[diffNorm.x := 2*a2*t + a1;
diffNorm.y := 2*b2*t + b1;]]></ST>
      </Implementation>
    </Method>
    <Method Name="ds" Id="{3d2a4728-15f9-4cb9-b2e5-b0a48c0c390b}">
      <Declaration><![CDATA[METHOD ds : LREAL
VAR_INPUT
	t: LREAL;
END_VAR
VAR
	dPos: RobotPoseSimple; //first order derivative of BezierCurve after t
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[dPos := diffNorm(t);
ds := sqrt(EXPT(dPos.x,2) + EXPT(dPos.y,2));]]></ST>
      </Implementation>
    </Method>
    <Method Name="getPoint" Id="{57091a75-4f60-4339-af74-b7d910e12667}">
      <Declaration><![CDATA[METHOD PUBLIC  getPoint : RobotPoseSimple
VAR_INPUT
	arcLength: LREAL; //corresponds to 's' in MATLAB
END_VAR

VAR
	t: LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[t := normalize(arcLength);
getPoint := getPointNorm(t);]]></ST>
      </Implementation>
    </Method>
    <Method Name="getPointNorm" Id="{49f32db8-2f61-495e-a08a-ce60065a3eb6}">
      <Declaration><![CDATA[METHOD getPointNorm : RobotPoseSimple
VAR_INPUT
	t: LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[getPointNorm.x   := a2*EXPT(t,2) + a1* t + a0;
getPointNorm.y   := b2*EXPT(t,2) +b1 * t + b0;
getPointNorm.theta := -1; //unused]]></ST>
      </Implementation>
    </Method>
    <Method Name="getStartEndPoint" Id="{2a56e530-9f6d-479f-a020-5589e1799307}">
      <Declaration><![CDATA[METHOD getStartEndPoint : RobotPoseSimple
VAR_INPUT
END_VAR

VAR
	phi1, zpx11, zpx12, zpy11, zpy12, zpx1, zpy1: LREAL;
	phi2, zpx21, zpx22, zpy21, zpy22, zpx2, zpy2: LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Start point:
// - angle of incidence of former linear part
phi1 := ATAN2(prevWP.y - controlPoint.y,prevWP.x - controlPoint.x);

// - x-coordinates where former linear part intersects with circle
zpx11 := controlPoint.x - radius*COS(phi1);
zpx12 := controlPoint.x + radius*COS(phi1);

//- y-coordinates where former linear part intersects with circle
zpy11 := controlPoint.y - radius*SIN(phi1);
zpy12 := controlPoint.y + radius*SIN(phi1);

//- decide which of the 2 solutions the relevant one
//(left or right intersection)
IF prevWP.x < controlPoint.x THEN
	zpx1 := MIN(zpx11, zpx12);
ELSE
	zpx1 := MAX(zpx11, zpx12);
END_IF

//- decide which of the 2 solutions the relevant one
//(left or right intersection)
IF prevWP.y < controlPoint.y THEN
	zpy1 := MIN(zpy11, zpy12);
ELSE
	zpy1 := MAX(zpy11, zpy12);
END_IF

//ZP 2:
//- angle of incidence of following linear part
phi2 := atan2(nextWP.y - controlPoint.y, nextWP.x - controlPoint.x);

// - x-coordinates where following linear part intersects with circle
zpx21 := controlPoint.x - radius*COS(phi2);
zpx22 := controlPoint.x + radius*COS(phi2);

//- y-coordinates where former linear part intersects with circle
zpy21 := controlPoint.y - radius * SIN(phi2);
zpy22 := controlPoint.y + radius * SIN(phi2);

// - decide which OF the 2 solutions the relevant one
// (left or right intersection)
IF nextWP.x < controlPoint.x THEN
	zpx2 := MIN(zpx21, zpx22);
else
	zpx2 := MAX(zpx21, zpx22); 
END_IF

IF nextWP.y < controlPoint.y THEN
	zpy2 := MIN(zpy21, zpy22);
else
	zpy2 := MAX(zpy21, zpy22);
END_IF


startPoint.x := zpx1;
startPoint.y := zpy1;
startPoint.theta := phi1;
endPoint.x := zpx2;
endPoint.y := zpy2;
endPoint.theta := phi2;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="normalize" Id="{c3312aa7-eada-49a4-95d3-f62358222036}">
      <Declaration><![CDATA[METHOD normalize : LREAL
VAR_INPUT
	arcLength: LREAL; //corresponds to 's' in MATLAB
END_VAR

VAR
	t_prev: LREAL;
	tol: LREAL := 1E-4;
	i: INT := 0;
	t: LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[t_prev := 1;
WHILE ABS(t-t_prev) > tol AND i < 100 DO
	t_prev := t;
	t := t - (tToArcLength(t) - arcLength) / ds(t);
	i := i +1;
END_WHILE
normalize := t;]]></ST>
      </Implementation>
    </Method>
    <Method Name="tToArcLength" Id="{d62a1d20-fa3f-41cc-b82f-8c6498fcbcf3}">
      <Declaration><![CDATA[METHOD tToArcLength : LREAL //s(t), corresponds to MATLAB method s in BezierCurve
VAR_INPUT
	t: LREAL;
END_VAR
VAR
	It, I0: LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[tToArcLength := tToArcLengthIntegral(t) - tToArcLengthIntegral(0);]]></ST>
      </Implementation>
    </Method>
    <Method Name="tToArcLengthIntegral" Id="{3ba382f4-0e5a-4c07-b8df-241d7bde34f7}">
      <Declaration><![CDATA[METHOD tToArcLengthIntegral : LREAL
VAR_INPUT
	t: LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[tToArcLengthIntegral := (4*a2*a1 + 4*b2*b1)/(4*(4*EXPT(a2,2) + 4*EXPT(b2,2)))*(t*(4*a2*a1 + 4*b2*b1) + EXPT(a1,2) + EXPT(b1,2) + EXPT(t,2)*EXPT((4*EXPT(a2,2) + 4*EXPT(b2,2)),(1/2))- 
(LOG((2*a2*a1 + 2*b2*b1 + t*(4*EXPT(a2,2) + 4*EXPT(b2,2)))/EXPT(4*EXPT(a2,2) 
+ 4*EXPT(b2,2),(1/2)) + SQRT(t*(4*a2*a1 + 4*b2*b1) + EXPT(a1,2) + EXPT(b1,2) + EXPT(t,2)*(4*EXPT(a2,2) + 4*EXPT(b2,2))))*(EXPT(4*a2*a1 + 4*b2*b1,2)/4
- (4*EXPT(a2,2) + 4*EXPT(b2,2))*(EXPT(a1,2) + EXPT(b1,2)))) / (2*EXPT(4*EXPT(a2,2) + 4*EXPT(b2,2),(3/2))));]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="BezierCurve">
      <LineId Id="9" Count="0" />
      <LineId Id="21" Count="1" />
      <LineId Id="24" Count="0" />
      <LineId Id="27" Count="1" />
      <LineId Id="30" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="33" Count="1" />
      <LineId Id="29" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="35" Count="1" />
    </LineIds>
    <LineIds Name="BezierCurve.calculateCoefficients">
      <LineId Id="6" Count="5" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="BezierCurve.calculateLength">
      <LineId Id="13" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="BezierCurve.dds">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="BezierCurve.diff">
      <LineId Id="9" Count="1" />
      <LineId Id="13" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="35" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="37" Count="1" />
      <LineId Id="23" Count="1" />
      <LineId Id="36" Count="0" />
      <LineId Id="31" Count="3" />
      <LineId Id="22" Count="0" />
      <LineId Id="26" Count="2" />
      <LineId Id="25" Count="0" />
    </LineIds>
    <LineIds Name="BezierCurve.diff2Norm">
      <LineId Id="5" Count="0" />
      <LineId Id="7" Count="1" />
    </LineIds>
    <LineIds Name="BezierCurve.diffNorm">
      <LineId Id="5" Count="0" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="BezierCurve.ds">
      <LineId Id="9" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="BezierCurve.getPoint">
      <LineId Id="6" Count="0" />
      <LineId Id="8" Count="0" />
    </LineIds>
    <LineIds Name="BezierCurve.getPointNorm">
      <LineId Id="7" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="8" Count="0" />
    </LineIds>
    <LineIds Name="BezierCurve.getStartEndPoint">
      <LineId Id="21" Count="1" />
      <LineId Id="5" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="27" Count="1" />
      <LineId Id="36" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="37" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="33" Count="1" />
      <LineId Id="32" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="46" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="44" Count="0" />
      <LineId Id="40" Count="0" />
      <LineId Id="43" Count="0" />
      <LineId Id="41" Count="0" />
      <LineId Id="48" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="49" Count="0" />
      <LineId Id="51" Count="3" />
      <LineId Id="50" Count="0" />
      <LineId Id="56" Count="2" />
      <LineId Id="55" Count="0" />
      <LineId Id="60" Count="13" />
      <LineId Id="75" Count="6" />
      <LineId Id="74" Count="0" />
      <LineId Id="59" Count="0" />
    </LineIds>
    <LineIds Name="BezierCurve.normalize">
      <LineId Id="7" Count="3" />
      <LineId Id="16" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="18" Count="0" />
    </LineIds>
    <LineIds Name="BezierCurve.tToArcLength">
      <LineId Id="15" Count="0" />
    </LineIds>
    <LineIds Name="BezierCurve.tToArcLengthIntegral">
      <LineId Id="7" Count="2" />
      <LineId Id="5" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>