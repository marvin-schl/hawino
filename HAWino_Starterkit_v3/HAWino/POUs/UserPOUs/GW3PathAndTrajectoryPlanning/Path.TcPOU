<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="Path" Id="{95fe6ec8-af15-4fc0-b4c5-550c7aba9b73}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK Path EXTENDS Spline
VAR_INPUT
	waypointListRaw: 	ARRAY [0..101] OF RobotPoseSimple;
	maxRadius: 			LREAL;
	thetaDZ: 			LREAL := 0.1;
END_VAR
VAR_OUTPUT
	ready: 				BOOL;
END_VAR
VAR
	waypointList: 		ARRAY [0..101] 	OF 	RobotPoseSimple;
		
	subsplines: 		ARRAY [0..100] 	OF  POINTER TO Spline;
	linearSplines:		ARRAY [0..51] OF LinearSpline;
	bezierCurves:		ARRAY [0..49] OF BezierCurve;
	
	transitions: 		ARRAY [0..100] 	OF LREAL;
	nmbOfSubsplines, nmbOfPreprocessedWaypoints: INT;
	subsplineGenerationIdx:					INT := 1;
	generatedSubsplines:				BOOL := FALSE;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[IF NOT generatedSubsplines THEN
	preprocessWaypointlist();
	nmbOfSubsplines := 2*nmbOfPreprocessedWaypoints-3;
	generateSubsplines();	
END_IF

IF generatedSubsplines AND NOT ready THEN
	lengthVar := calculateLength();
	calculateTransitions();
	
	startPoint := subsplines[0]^.startPointVal;
	endPoint   := subsplines[nmbOfSubsplines-1]^.endPointVal;
	
	startPoint.theta := waypointList[0].theta;
	
	
	endPoint.theta	 := waypointList[nmbOfPreprocessedWaypoints-1].theta;
	IF ABS(endPoint.theta-startPoint.theta) > ABS(endPoint.theta+2*pi-startPoint.theta) THEN
		endPoint.theta := endPoint.theta+2*pi;
	ELSIF ABS(endPoint.theta-startPoint.theta) > ABS(endPoint.theta-2*pi-startPoint.theta) THEN
		endPoint.theta := endPoint.theta-2*pi;
	END_IF
	ready := TRUE;
END_IF
]]></ST>
    </Implementation>
    <Method Name="calculateLength" Id="{fa9150c3-1548-4fad-bc03-2a7bdbb95fff}">
      <Declaration><![CDATA[(* 
Implementation of abstract Spline method.
For internal inital length calculation, should be called in the constructor => protected
*)
METHOD PROTECTED  calculateLength : LREAL
VAR_INPUT
END_VAR
VAR
	i: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[calculateLength := 0;
FOR i := 0 TO nmbOfSubsplines-1 DO
	calculateLength := calculateLength + subsplines[i]^.length;
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="calculateTransitions" Id="{52dbb64c-0f38-4919-8d0f-8a50326cf34d}">
      <Declaration><![CDATA[METHOD PRIVATE calculateTransitions
VAR_INPUT
END_VAR
VAR
	i : INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[transitions[0] := 0;
FOR i := 0 TO nmbOfSubsplines-2 DO
	transitions[i+1] := transitions[i] + subsplines[i]^.length;
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="diff" Id="{c435850d-099e-4883-9ebf-b0187bee6499}">
      <Declaration><![CDATA[(* 
Implementation of abstract Spline method.
Calculates the derivate of the spline at an arbitrary arcLength. Should be implmented for order one and two. Invalid 
orders should write a -1 in every component of the return value.
*)
METHOD  PUBLIC diff : RobotPoseSimple
VAR_INPUT
	arcLength: LREAL; //arcLength at which the corresponding derivative should be calculated
	order: INT := 1;  //optional: order of the derivate, should be implemented for 1 and 2, default: 1
END_VAR
VAR
	subspline: 				POINTER TO Spline;
	arcOffset, deltaTheta: 	LREAL;
	dPos: RobotPoseSimple;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[getSubsplineToPoint(arcLength := arcLength,
					subspline => subspline,
					arcOffset => arcOffset);
deltaTheta:= endPoint.theta - startPoint.theta; 		
diff 		:= subspline^.diff(arcLength := arcOffset, order:= order);	
diff.theta 	:= dTheta(arcLength := arcLength, order := order);]]></ST>
      </Implementation>
    </Method>
    <Method Name="dTheta" Id="{7d2d238e-6c7d-41bf-901f-e1aba91ddba5}">
      <Declaration><![CDATA[METHOD PRIVATE dTheta : LREAL
VAR_INPUT
	arcLength: LREAL;
	order: INT;
END_VAR
VAR
	deltaTheta: LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[deltaTheta := endPoint.theta - startPoint.theta;
IF arcLength < thetaDZ  OR arcLength > lengthVar - thetaDZ THEN
	dTheta := 0;
ELSIF order = 1 THEN
	dTheta := deltaTheta/2*(pi/(lengthVar-2*thetaDZ))*SIN(pi/(lengthVar-2*thetaDZ)*(arcLength-thetaDZ));
ELSIF order = 2 THEN
	dTheta := deltaTheta/2*EXPT(pi/(lengthVar-2*thetaDZ),2)*COS(pi/(lengthVar-2*thetaDZ)*(arcLength-thetaDZ));
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="generateSubsplines" Id="{64c26576-c972-4416-a2f8-ea26c3f38e4d}">
      <Declaration><![CDATA[METHOD generateSubsplines : BOOL
VAR_INPUT
END_VAR
VAR

			
	//xTmpLinear,yTmpLinear:    		ARRAY [0..1] OF LREAL;
	wplTmpLinear:					ARRAY [0..1] OF RobotPoseSimple;
	//xTmpBezier,yTmpBezier:    		ARRAY [0..2] OF LREAL;
	wplTmpBezier:					ARRAY [0..2] OF RobotPoseSimple;
	
	i,j,k: INT := 0;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF nmbOfSubsplines <> 1 AND NOT ready THEN 
	IF subsplineGenerationIdx = 0 THEN
		//first Segment is always linear
		wplTmpLinear[0] := waypointList[0];
		wplTmpLinear[1] := subsplines[1]^.startPointVal;
		linearSplines[0](wayPoints := wplTmpLinear);
		subsplines[0] := ADR(linearSplines[0]);
		subsplineGenerationIdx := nmbOfSubsplines-1;
	ELSIF subsplineGenerationIdx = nmbOfSubsplines-1 THEN
		//last Segment is always linear
		wplTmpLinear[0] := subsplines[nmbOfSubsplines-2]^.endPointVal;
		wplTmpLinear[1] := waypointList[nmbOfPreprocessedWaypoints-1];
		linearSplines[(nmbOfSubsplines+1)/2](wayPoints := wplTmpLinear);
		subsplines[nmbOfSubsplines-1] := ADR(linearSplines[(nmbOfSubsplines+1)/2]);
		subsplineGenerationIdx := 2;
	ELSIF (subsplineGenerationIdx MOD 2) <> 0 THEN
		i := subsplineGenerationIdx;
		k := 0;
		
		//extract relevant points for bezier curve creation
		FOR j := (i-1)/2 TO (i-1)/2+2 BY 1 DO
			wplTmpBezier[k] := waypointList[j];
			k := k + 1;
		END_FOR
  
		bezierCurves[(i-1)/2](waypoints:=wplTmpBezier, maxRadius := maxRadius);
		subsplines[i]:= ADR(bezierCurves[(i-1)/2]);
		
		IF subsplineGenerationIdx >= nmbOfSubsplines-2 THEN
			subsplineGenerationIdx := 0;
		ELSE 
			subsplineGenerationIdx := i+2;
		END_IF
	ELSIF (subsplineGenerationIdx MOD 2) = 0 THEN
		i := subsplineGenerationIdx;
		wplTmpLinear[0] := subsplines[i-1]^.endPointVal;
		wplTmpLinear[1] := subsplines[i+1]^.startPointVal;
		linearSplines[i/2](wayPoints := wplTmpLinear);
		subsplines[i] := ADR(linearSplines[i/2]);
		IF subsplineGenerationIdx >= nmbOfSubsplines-3 THEN
			generatedSubsplines := TRUE;
		ELSE	
		subsplineGenerationIdx := subsplineGenerationIdx + 2;
		END_IF
	END_IF
ELSIF nmbOfSubsplines = 1 AND NOT ready THEN  //nmbOfSubsplines = 1  => only one linear Segment
	wplTmpLinear[0] := waypointList[0];
	wplTmpLinear[1] := waypointList[1];;
	linearSplines[0](wayPoints := wplTmpLinear);
	subsplines[0] := ADR(linearSplines[0]);
	generatedSubsplines := TRUE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="getPoint" Id="{edc81ff7-b7ad-4aac-a526-a3258fc65de9}">
      <Declaration><![CDATA[(*
Implementation of abstract Spline method.
Gets the configuration of the Spline at any given arcLength. 
*)
METHOD PUBLIC  getPoint : RobotPoseSimple
VAR_INPUT
	arcLength: LREAL; //arcLength at which the Splines configuration shall be calculated.
END_VAR
VAR
	subspline: POINTER TO Spline;
	arcOffset: LREAL;
	deltaTheta: LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[getSubsplineToPoint(arcLength := arcLength,
					subspline => subspline,
					arcOffset => arcOffset);
getPoint := subspline^.getPoint(arcLength:= arcOffset);

deltaTheta 		:= endPoint.theta - startPoint.theta;
getPoint.theta	:= theta(arcLength := arcLength);]]></ST>
      </Implementation>
    </Method>
    <Method Name="getSubsplineToPoint" Id="{d9693a58-8dc8-4612-b85b-8d181f60b2f3}">
      <Declaration><![CDATA[METHOD PRIVATE getSubsplineToPoint : POINTER TO Spline
VAR_INPUT
	arcLength: LREAL;
END_VAR

VAR_OUTPUT
	subspline: 	POINTER TO Spline;
	arcOffset: 	LREAL;
	i: 			INT := 0;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[arcOffset := arcLength;
IF arcLength >= length THEN
	arcOffset := arcLength - transitions[nmbOfSubsplines-1];
	subspline := subsplines[nmbOfSubsplines-1];
	RETURN;
END_IF

FOR i := 0 TO nmbOfSubsplines-1 DO
	IF arcOffset-subsplines[i]^.length < 0 THEN
		subspline := subsplines[i];
		EXIT;
	ELSE
		arcOffset := arcOffset -subsplines[i]^.length;
	END_IF
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="getSwitchingPointIntervals" Id="{cfaa726c-df69-48c1-84c4-a6f3a80b3d25}">
      <Declaration><![CDATA[METHOD getSwitchingPointIntervals : ARRAY [0..98] OF LREAL
VAR_INPUT
END_VAR
VAR
	i: INT := 0;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[FILL(arr :=  getSwitchingPointIntervals, val := -1.0);
FOR i := 1 TO nmbOfSubsplines-1 BY 1 DO
	getSwitchingPointIntervals[i-1] := transitions[i];
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="preprocessWaypointlist" Id="{eb2abc10-4b35-4a8b-a276-447cab2534b7}">
      <Declaration><![CDATA[METHOD PRIVATE preprocessWaypointlist 
VAR_IN_OUT
END_VAR
VAR 
	i : 				INT 			:= 0;
	nextIDX: 			INT;
	phi1, phi2: 		LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[waypointList[0].theta := waypointListRaw[0].theta;	
waypointList[0].y := waypointListRaw[0].y/1000;	
waypointList[0].x := waypointListRaw[0].x/1000;	
nextIDX := 1;

FOR i := 1 TO 99 DO
	//exit if last point is reached, last valid point is last point in preprocessed list
	IF waypointListRaw[i+1].x = -1 AND waypointListRaw[i+1].y = -1 THEN
		waypointList[nextIDX].theta := waypointListRaw[i].theta;	
		waypointList[nextIDX].y := waypointListRaw[i].y/1000;	
		waypointList[nextIDX].x := waypointListRaw[i].x/1000;	
		EXIT;
	END_IF	

	phi1 := ATAN2(waypointListRaw[i].y-waypointListRaw[i-1].y,waypointListRaw[i].x-waypointListRaw[i-1].x);
	phi2 := ATAN2(waypointListRaw[i+1].y-waypointListRaw[i].y,waypointListRaw[i+1].x-waypointListRaw[i].x);
	IF phi1 <> phi2 AND phi1 <> normalizeAngle(phi2+pi, pi, -pi) THEN
		waypointList[nextIDX].theta := waypointListRaw[i].theta;	
		waypointList[nextIDX].y := waypointListRaw[i].y/1000;	
		waypointList[nextIDX].x := waypointListRaw[i].x/1000;	
		nextIDX := nextIDX +1;
	END_IF
END_FOR
nmbOfPreprocessedWaypoints := nextIDX +1;]]></ST>
      </Implementation>
    </Method>
    <Method Name="reset" Id="{817d8fbe-9d0e-4b33-9f5d-4bd7fb35cdde}">
      <Declaration><![CDATA[METHOD reset : LREAL
VAR_INPUT
END_VAR
VAR
	i: INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[startPoint.x 	:= 0;
startPoint.y	:= 0;
startPoint.theta:= 0;

endPoint.x 	:= 0;
endPoint.y	:= 0;
endPoint.theta:= 0;

generatedSubsplines := FALSE;
ready := FALSE;
subsplineGenerationIdx := 1;

//FOR i := 0 TO nmbOfPreprocessedWaypoints-1 BY 1 DO
//	waypointList[i].x 	:= 0;
//	waypointList[i].y	:= 0;
//	waypointList[i].theta:= 0;
//END_FOR

//FOR i := 0 TO nmbOfSubsplines-1 BY 1 DO 
//	subsplines[i] := 0;
//END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="theta" Id="{3e06842d-afd1-418d-bfed-0a225c6266f7}">
      <Declaration><![CDATA[METHOD PRIVATE theta : LREAL
VAR_INPUT
	arcLength: LREAL;
END_VAR
VAR
	deltaTheta: LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[deltaTheta := endPoint.theta - startPoint.theta;
IF arcLength < thetaDZ THEN
	theta := startPoint.theta;
ELSIF arcLength > lengthVar - thetaDZ THEN
	theta := endPoint.theta;
ELSE
	theta := startPoint.theta + deltaTheta/2*(1-COS(pi/(lengthVar-2*thetaDZ)*(arcLength-thetaDZ)));
END_IF ]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="Path">
      <LineId Id="359" Count="0" />
      <LineId Id="362" Count="2" />
      <LineId Id="361" Count="0" />
      <LineId Id="358" Count="0" />
      <LineId Id="354" Count="0" />
      <LineId Id="317" Count="3" />
      <LineId Id="96" Count="0" />
      <LineId Id="336" Count="0" />
      <LineId Id="335" Count="0" />
      <LineId Id="387" Count="1" />
      <LineId Id="337" Count="0" />
      <LineId Id="389" Count="1" />
      <LineId Id="392" Count="1" />
      <LineId Id="391" Count="0" />
      <LineId Id="365" Count="0" />
      <LineId Id="355" Count="1" />
    </LineIds>
    <LineIds Name="Path.calculateLength">
      <LineId Id="22" Count="2" />
      <LineId Id="11" Count="0" />
    </LineIds>
    <LineIds Name="Path.calculateTransitions">
      <LineId Id="21" Count="2" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="Path.diff">
      <LineId Id="57" Count="4" />
      <LineId Id="17" Count="0" />
    </LineIds>
    <LineIds Name="Path.dTheta">
      <LineId Id="15" Count="6" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="Path.generateSubsplines">
      <LineId Id="22" Count="0" />
      <LineId Id="77" Count="0" />
      <LineId Id="112" Count="3" />
      <LineId Id="109" Count="0" />
      <LineId Id="120" Count="0" />
      <LineId Id="111" Count="0" />
      <LineId Id="116" Count="3" />
      <LineId Id="110" Count="0" />
      <LineId Id="121" Count="0" />
      <LineId Id="148" Count="16" />
      <LineId Id="147" Count="0" />
      <LineId Id="106" Count="1" />
      <LineId Id="123" Count="2" />
      <LineId Id="122" Count="0" />
      <LineId Id="165" Count="0" />
      <LineId Id="127" Count="0" />
      <LineId Id="167" Count="0" />
      <LineId Id="166" Count="0" />
      <LineId Id="126" Count="0" />
      <LineId Id="79" Count="0" />
      <LineId Id="55" Count="0" />
      <LineId Id="57" Count="3" />
      <LineId Id="146" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="Path.getPoint">
      <LineId Id="30" Count="2" />
      <LineId Id="13" Count="0" />
      <LineId Id="37" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="35" Count="0" />
    </LineIds>
    <LineIds Name="Path.getSubsplineToPoint">
      <LineId Id="39" Count="1" />
      <LineId Id="46" Count="0" />
      <LineId Id="50" Count="2" />
      <LineId Id="13" Count="0" />
      <LineId Id="18" Count="2" />
      <LineId Id="2" Count="0" />
      <LineId Id="53" Count="3" />
    </LineIds>
    <LineIds Name="Path.getSwitchingPointIntervals">
      <LineId Id="27" Count="2" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="Path.preprocessWaypointlist">
      <LineId Id="95" Count="1" />
      <LineId Id="79" Count="0" />
      <LineId Id="60" Count="3" />
      <LineId Id="82" Count="0" />
      <LineId Id="93" Count="1" />
      <LineId Id="81" Count="0" />
      <LineId Id="67" Count="4" />
      <LineId Id="104" Count="0" />
      <LineId Id="83" Count="0" />
      <LineId Id="91" Count="1" />
      <LineId Id="75" Count="2" />
      <LineId Id="43" Count="0" />
    </LineIds>
    <LineIds Name="Path.reset">
      <LineId Id="5" Count="0" />
      <LineId Id="7" Count="1" />
      <LineId Id="10" Count="2" />
      <LineId Id="9" Count="0" />
      <LineId Id="35" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="6" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="21" Count="1" />
    </LineIds>
    <LineIds Name="Path.theta">
      <LineId Id="13" Count="6" />
      <LineId Id="5" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>