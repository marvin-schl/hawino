<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="BezierCurve" Id="{e77832cf-db41-4e37-bb04-ef53ff8726aa}" SpecialFunc="None">
    <Declaration><![CDATA[(* Class: BezierCurve
This class implements a quadratic BezierCurve. A quadratic BezierCurve is uniquely defined by three Points. In this 
specific application the three points are generated from three Waypoints, a previous, the corner, and the next Waypoint. The corner
Point is directly used as controlPoint. From the prev and nex Wapoints the start and endPoints are generated by intersection of Linear 

*)
FUNCTION_BLOCK BezierCurve EXTENDS Spline
VAR_INPUT
	waypoints: ARRAY[0..2] OF RobotPoseSimple;
	radius: LREAL;
	deltaT: LREAL := 1E-3; //only for inital length calculation
END_VAR
VAR_OUTPUT
END_VAR
VAR
	prevWP, nextWP, controlPoint: RobotPoseSimple;
	a2, a1, a0, b2, b1, b0: LREAL;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[controlPoint := waypoints[1];
prevWP := waypoints[0];
nextWP := waypoints[2];

getStartEndPoint();
calculateCoefficients();
lengthVar := calculateLength();]]></ST>
    </Implementation>
    <Method Name="calculateCoefficients" Id="{358aa45f-b3d6-4b2a-8e91-98e0c973e800}">
      <Declaration><![CDATA[METHOD PRIVATE calculateCoefficients 
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[a2 := (startPoint.x - 2*controlPoint.x + endPoint.x);
a1 := (2*controlPoint.x - 2*startPoint.x);
a0 := startPoint.x;

b2 := (startPoint.y - 2*controlPoint.y + endPoint.y);
b1 := (2*controlPoint.y - 2*startPoint.y);
b0 := startPoint.y;]]></ST>
      </Implementation>
    </Method>
    <Method Name="calculateLength" Id="{022b5e9a-942d-4cb5-a32c-ca554c58b677}">
      <Declaration><![CDATA[(* 
Implementation of abstract Spline method.
For internal inital length calculation, should be called in the constructor => protected
*)
METHOD PROTECTED  calculateLength : LREAL
VAR_INPUT
END_VAR

VAR
	i : INT;
	t : LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[calculateLength := 0;
FOR i := 0 TO LREAL_TO_INT(1/deltaT)-1 DO
	t := i*deltaT;
	calculateLength := calculateLength + ds(t)*deltaT;
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="dds" Id="{6ecd8f45-18bb-42aa-9825-094704a154e9}">
      <Declaration><![CDATA[METHOD PRIVATE dds : LREAL
VAR_INPUT
	t, dsVal: LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[dds := (4*(EXPT(a2,2)+EXPT(b2,2))*t + 2*(a2*a1+b2*b1))/dsVal;]]></ST>
      </Implementation>
    </Method>
    <Method Name="diff" Id="{77e3fbe0-c097-4aa1-89b4-63503c3b240c}">
      <Declaration><![CDATA[(* 
Implementation of abstract Spline method.
Calculates the derivate of the spline at an arbitrary arcLength. Should be implmented for order one and two. Invalid 
orders should write a -1 in every component of the return value.
*)
METHOD PUBLIC diff : RobotPoseSimple
VAR_INPUT
	arcLength: LREAL; //arcLength at which the corresponding derivative should be calculated
	order: INT := 1;  //optional: order of the derivate, should be implemented for 1 and 2, default: 1
END_VAR
VAR
	t, dsVal, ddsVal: LREAL;
	dPos, ddPos: RobotPoseSimple;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[t 		:= normalize(arcLength);
dPos	:= diffNorm(t);
dsVal 		:= ds(t);
diff.theta := -1;

CASE order OF
	1 :
		diff.x := dPos.x/dsVal;
		diff.y := dPos.y/dsVal;
	2 :
	   //calculate first derivative
	   //inner derivative
		ddsVal := dds(t, dsVal);
		ddPos  := diff2Norm(t);
		
		//calculate second derivate, derivation NOT trivial
		diff.x := ddPos.x*EXPT(dsVal,-2) - dPos.x*EXPT(dsVal, -3) *ddsVal;
		diff.y := ddPos.y*EXPT(dsVal,-2) - dPos.y*EXPT(dsVal, -3) *ddsVal;

ELSE
	diff.x := -1.0;
	diff.y := -1.0;
	diff.theta := -1.0;
END_CASE;  ]]></ST>
      </Implementation>
    </Method>
    <Method Name="diff2Norm" Id="{a87920c3-fb56-49d7-9c6d-2ae3c7511236}">
      <Declaration><![CDATA[METHOD PRIVATE diff2Norm : RobotPoseSimple
VAR_INPUT
	t: LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[diff2Norm.x 		:= 2*a2;
diff2Norm.y 		:= 2*b2;
diff2Norm.theta		:= -1; //unused ]]></ST>
      </Implementation>
    </Method>
    <Method Name="diffNorm" Id="{3ae2bbde-fdd7-43b3-9729-e14fa3e8ab1e}">
      <Declaration><![CDATA[METHOD PRIVATE diffNorm : RobotPoseSimple
VAR_INPUT
	t: LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[diffNorm.x := 2*a2*t + a1;
diffNorm.y := 2*b2*t + b1;]]></ST>
      </Implementation>
    </Method>
    <Method Name="ds" Id="{3d2a4728-15f9-4cb9-b2e5-b0a48c0c390b}">
      <Declaration><![CDATA[METHOD PRIVATE ds : LREAL
VAR_INPUT
	t: LREAL;
END_VAR
VAR
	dPos: RobotPoseSimple; //first order derivative of BezierCurve after t
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[dPos := diffNorm(t);
ds := sqrt(EXPT(dPos.x,2) + EXPT(dPos.y,2));]]></ST>
      </Implementation>
    </Method>
    <Method Name="getPoint" Id="{57091a75-4f60-4339-af74-b7d910e12667}">
      <Declaration><![CDATA[(*
Implementation of abstract Spline method.
Gets the configuration of the Spline at any given arcLength. 
*)
METHOD PUBLIC getPoint : RobotPoseSimple
VAR_INPUT
	arcLength: LREAL; //arcLength at which the Splines configuration shall be calculated. 
END_VAR

VAR
	t: LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[t := normalize(arcLength);
getPoint := getPointNorm(t);]]></ST>
      </Implementation>
    </Method>
    <Method Name="getPointNorm" Id="{49f32db8-2f61-495e-a08a-ce60065a3eb6}">
      <Declaration><![CDATA[METHOD PRIVATE getPointNorm : RobotPoseSimple
VAR_INPUT
	t: LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[getPointNorm.x   := a2*EXPT(t,2) + a1* t + a0;
getPointNorm.y   := b2*EXPT(t,2) +b1 * t + b0;
getPointNorm.theta := -1; //unused]]></ST>
      </Implementation>
    </Method>
    <Method Name="getStartEndPoint" Id="{2a56e530-9f6d-479f-a020-5589e1799307}">
      <Declaration><![CDATA[METHOD PRIVATE getStartEndPoint : RobotPoseSimple
VAR_INPUT
END_VAR

VAR
	phi1, zpx11, zpx12, zpy11, zpy12, zpx1, zpy1: LREAL;
	phi2, zpx21, zpx22, zpy21, zpy22, zpx2, zpy2: LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Start point:
// - angle of incidence of former linear part
phi1 := ATAN2(prevWP.y - controlPoint.y, prevWP.x - controlPoint.x);

// - x-coordinates where former linear part intersects with circle
zpx11 := controlPoint.x - radius*COS(phi1);
zpx12 := controlPoint.x + radius*COS(phi1);

//- y-coordinates where former linear part intersects with circle
zpy11 := controlPoint.y - radius*SIN(phi1);
zpy12 := controlPoint.y + radius*SIN(phi1);

//- decide which of the 2 solutions the relevant one
//(left or right intersection)
IF prevWP.x < controlPoint.x THEN
	zpx1 := MIN(zpx11, zpx12);
ELSE
	zpx1 := MAX(zpx11, zpx12);
END_IF

//- decide which of the 2 solutions the relevant one
//(left or right intersection)
IF prevWP.y < controlPoint.y THEN
	zpy1 := MIN(zpy11, zpy12);
ELSE
	zpy1 := MAX(zpy11, zpy12);
END_IF

//ZP 2:
//- angle of incidence of following linear part
phi2 := atan2(nextWP.y - controlPoint.y, nextWP.x - controlPoint.x);

// - x-coordinates where following linear part intersects with circle
zpx21 := controlPoint.x - radius*COS(phi2);
zpx22 := controlPoint.x + radius*COS(phi2);

//- y-coordinates where former linear part intersects with circle
zpy21 := controlPoint.y - radius * SIN(phi2);
zpy22 := controlPoint.y + radius * SIN(phi2);

// - decide which OF the 2 solutions the relevant one
// (left or right intersection)
IF nextWP.x < controlPoint.x THEN
	zpx2 := MIN(zpx21, zpx22);
else
	zpx2 := MAX(zpx21, zpx22); 
END_IF

IF nextWP.y < controlPoint.y THEN
	zpy2 := MIN(zpy21, zpy22);
else
	zpy2 := MAX(zpy21, zpy22);
END_IF


startPoint.x := zpx1;
startPoint.y := zpy1;
startPoint.theta := phi1;
endPoint.x := zpx2;
endPoint.y := zpy2;
endPoint.theta := phi2;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="normalize" Id="{c3312aa7-eada-49a4-95d3-f62358222036}">
      <Declaration><![CDATA[METHOD PRIVATE normalize : LREAL
VAR_INPUT
	arcLength: LREAL; //corresponds to 's' in MATLAB
END_VAR

VAR
	t_prev: LREAL;
	tol: LREAL := 1E-4;
	i: INT := 0;
	t: LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[t_prev := 2;
WHILE ABS(t-t_prev) > tol AND i < 100 DO
	t_prev := t;
	t := t - (tToArcLength(t) - arcLength) / ds(t);
	i := i +1;
END_WHILE
normalize := t;]]></ST>
      </Implementation>
    </Method>
    <Method Name="tToArcLength" Id="{d62a1d20-fa3f-41cc-b82f-8c6498fcbcf3}">
      <Declaration><![CDATA[METHOD PRIVATE tToArcLength : LREAL //s(t), corresponds to MATLAB method s in BezierCurve
VAR_INPUT
	t: LREAL;
END_VAR
VAR
	It, I0: LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[tToArcLength := tToArcLengthIntegral(t) - tToArcLengthIntegral(0);]]></ST>
      </Implementation>
    </Method>
    <Method Name="tToArcLengthIntegral" Id="{3ba382f4-0e5a-4c07-b8df-241d7bde34f7}">
      <Declaration><![CDATA[METHOD PRIVATE tToArcLengthIntegral : LREAL
VAR_INPUT
	t: LREAL;
END_VAR
VAR
	z1,z2,z3,z4,z5,z6:LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[z2 :=4*a2*a1+4*b1*b2;
z3 := 4*EXPT(a2,2)+4*EXPT(b2,2);
z6 := EXPT(a1,2)+EXPT(b1,2);
z1 := t*z2+z6+EXPT(t,2)*z3;
z4 :=(z2/2+t*z3)/SQRT(z3)+ SQRT((t*z2+z6+EXPT(t,2)*z3));
z5 := LN(z4);
tToArcLengthIntegral := (t/2 + z2 / (4*z3)) * SQRT(z1) - (z5* ((EXPT(z2,2) / 4-z3*z6))) / (2*SQRT(EXPT(z3,3) ));


]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="BezierCurve">
      <LineId Id="78" Count="1" />
      <LineId Id="92" Count="0" />
      <LineId Id="87" Count="2" />
      <LineId Id="36" Count="0" />
    </LineIds>
    <LineIds Name="BezierCurve.calculateCoefficients">
      <LineId Id="18" Count="5" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="BezierCurve.calculateLength">
      <LineId Id="29" Count="3" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="BezierCurve.dds">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="BezierCurve.diff">
      <LineId Id="55" Count="22" />
      <LineId Id="25" Count="0" />
    </LineIds>
    <LineIds Name="BezierCurve.diff2Norm">
      <LineId Id="17" Count="1" />
      <LineId Id="8" Count="0" />
    </LineIds>
    <LineIds Name="BezierCurve.diffNorm">
      <LineId Id="20" Count="0" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="BezierCurve.ds">
      <LineId Id="22" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="BezierCurve.getPoint">
      <LineId Id="23" Count="0" />
      <LineId Id="8" Count="0" />
    </LineIds>
    <LineIds Name="BezierCurve.getPointNorm">
      <LineId Id="17" Count="1" />
      <LineId Id="8" Count="0" />
    </LineIds>
    <LineIds Name="BezierCurve.getStartEndPoint">
      <LineId Id="96" Count="60" />
      <LineId Id="59" Count="0" />
    </LineIds>
    <LineIds Name="BezierCurve.normalize">
      <LineId Id="39" Count="5" />
      <LineId Id="18" Count="0" />
    </LineIds>
    <LineIds Name="BezierCurve.tToArcLength">
      <LineId Id="15" Count="0" />
    </LineIds>
    <LineIds Name="BezierCurve.tToArcLengthIntegral">
      <LineId Id="21" Count="8" />
      <LineId Id="5" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>