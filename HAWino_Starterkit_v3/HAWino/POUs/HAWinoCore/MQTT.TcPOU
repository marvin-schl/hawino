<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="MQTT" Id="{3b364ef0-24c5-4b55-9f63-1e0f62f8b4d0}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM MQTT
VAR

// Identifikation des Roboters
    //Robot_Number	AT%I*	: INT;	


// Local Variables for Mqtt Client handling
	fbIotMqttClient : FB_IotMqttClient;
	//ClientId : STRING(255);
    //ClientId : STRING(255) := CONCAT('HAWino_', INT_TO_STRING(.Var_HAWIno.Robot_Number));
	bSetParameter 	: BOOL := TRUE;
	bConnect 		: BOOL := TRUE;	
	
// Publish message
	initMQTT : BOOL := FALSE;
	sTopicPubToPowerMgmt : STRING(255); //:= CONCAT('Robots/PowerMgmt/Robot_', INT_TO_STRING(.Var_HAWIno.Robot_Number)); 	// ToDo: Bisher ist die Nummer des HAWino fest kodiert
	sTopicPubToPowerMgmt_SOC : STRING(255);// := CONCAT('Robots/PowerMgmt/SoC_Robot_', INT_TO_STRING(.Var_HAWIno.Robot_Number)); 
	sTopicPubWaypointlist : STRING(255);
	sPayloadPub : STRING(2000);	
	fbTimerPub 	: TON := (PT:=T#500MS);									// Intervall für das Senden des Akku-Status
	
//Received message
	bSubscribed    : BOOL;
	sTopicSubToPowerMgmt : STRING(255);// := CONCAT('PowerMgmt/Robots/Robot_', INT_TO_STRING(.Var_HAWIno.Robot_Number));	// ToDo: Bisher ist die Nummer des HAWino fest kodiert
	sTopicRcv      : STRING(255);
	sPayloadRcv    : STRING(255);
	fbMessageQueue : FB_IotMqttMessageQueue;
    fbMessage      : FB_IotMqttMessage;
	hrErrorOccurred : HRESULT; 			// Enthlt dern letzten augetretenen Fehler
	
	sTopicSubTrajectory :STRING(255);
	sPayloadTrajectory : STRING(255);
	
// Variables for JSON
	fbJson			: FB_JsonSaxWriter;
	fbJsonDataType 	: FB_JsonReadWriteDataType;
	sJsonDoc       	: STRING(2000); 
	
	fbJsonParser	: FB_JsonDynDomParser;
	
// Local Variables for TwinCAT IoT Communication (TF6701) with direct link to EK1200 and TcCom
	//stMqtt_HAWino_In	AT%I*	: ST_PwrMgmt_HAWino_In;		// Attention! Don't link TIME Variables, otherwise we get an error!
	//stMqtt_HAWino_Out	AT%Q*	: ST_PwrMgmt_HAWino_Out;
	
	stMqtt_HAWino_In	 AT%I*: ST_PwrMgmt_HAWino_In;		// Attention! Don't link TIME Variables, otherwise we get an error!
	stMqtt_HAWino_Out	 AT%Q*: ST_PwrMgmt_HAWino_Out;
	
	SOC_Out : STRING(255);
	nBatteryTemperature	AT%I*	: INT;
	
	bComCheckAnswer	AT%Q*	: BOOL;
	
	stMqtt_HAWinoValues	: ST_PwrMgmt_HAWino;
	
	
// Timer to create a time stamp
	fbTimerTimestamp : TON := (PT:=T#71582M47S295MS);
	
// Local Vaiables to evaluate and act to input
	fbComCheckFlag	: RS;
	
	
	
	sTopicSubToFleetMgmt: STRING;
	Reset1: BOOL;
	//Input synccheck. robotdata has been read and can be used.
	txtReadInit AT%I* : BOOL := FALSE;
	
	
	
	// Check whether connected to Topic sTobicSubTrajectory
	bSubcribedTrajectory: BOOL;
	
	//Flag from GW2 when new Waypointlist
	inNewWpl AT%I* : BOOL := FALSE;
	// Waypointlist from GW2
	//inWaypointList AT%Q*: ARRAY[0..100] OF RobotPoseSimple;	// Wegpunktliste mit Roboter-Posen in globalen Koordinaten (x, y, theta)
	xWPL, yWPL, thetaWPL : ARRAY [0..2] OF LREAL;
	//TESTWPL : LREAL := 1.234;
	TESTWPL : ARRAY [0..2] OF RobotPoseSimple  := [(x:=1, y:=2, theta:=3), (x:=4, y:=5, theta:=6), (x:=7, y:=8, theta:=9)];
	TESTTRAJECTORY : STRING;
	
	//counter variable
	cnt : INT := 0;
	jsonDoc: Tc3_JsonXml.PVOID;
END_VAR


]]></Declaration>
    <Implementation>
      <ST><![CDATA[//Case machen! preop op

IF txtReadInit THEN
	IF NOT initMQTT THEN
		sTopicPubToPowerMgmt  := CONCAT('Robots/PowerMgmt/Robot_', INT_TO_STRING(.Var_HAWIno.Robot_Number)); 	
		sTopicPubToPowerMgmt_SOC  := CONCAT('Robots/PowerMgmt/SoC_Robot_', INT_TO_STRING(.Var_HAWIno.Robot_Number));
		sTopicPubWaypointlist := CONCAT('Robots/Waypointlist/Robot_', INT_TO_STRING(.Var_HAWIno.Robot_Number));
		sTopicSubToPowerMgmt  := CONCAT('PowerMgmt/Robots/Robot_', INT_TO_STRING(.Var_HAWIno.Robot_Number));
		sTopicSubTrajectory := CONCAT('Robots/Trajectory/Robot_', INT_TO_STRING(.Var_HAWIno.Robot_Number));
		initMQTT:= TRUE;
	END_IF
	
	stMqtt_HAWinoValues.Output.nRobotNumber := .Var_HAWIno.Robot_Number;			// Anpassen für jeden HAWino
	
	fbTimerTimestamp(In:= NOT fbTimerTimestamp.Q, ET=>stMqtt_HAWinoValues.Output.tTimestamp);
	
	stMqtt_HAWinoValues.Output.fSoC := stMqtt_HAWino_In.fSoC;
	
	stMqtt_HAWinoValues.Output.fActualBatteryCurrent := stMqtt_HAWino_In.fActualBatteryCurrent;
	stMqtt_HAWinoValues.Output.fActualBatteryVoltage := stMqtt_HAWino_In.fActualBatteryVoltage;
	
	//stMqtt_HAWinoValues.Output.fActualBatteryCurrent := stMqtt_HAWino_In.fActualBatteryCurrent;
	//stMqtt_HAWinoValues.Output.fActualBatteryVoltage := stMqtt_HAWino_In.fActualBatteryVoltage;
	
	
	
	
	// Skalierung der Temperaturwerte des Akkus
	stMqtt_HAWinoValues.Output.fBatteryTemperature := FKT_Scale(Rohwert := nBatteryTemperature, 
																	X1 := -500,
																	X2 := 1500, 
																	Y1 := -50,
																	Y2 := 150);
																	
	// Ausgabe der erwarteten Laufzeit des Roboters
	stMqtt_HAWinoValues.Output.nEstimatedRunningTime	:= LIMIT(0,stMqtt_HAWino_In.nEstimatedRunningTime,172800);		// Max. 48 Stunden sollen dargestellt werden
	stMqtt_HAWinoValues.Output.nEstimatedChargingTime	:= LIMIT(0,stMqtt_HAWino_In.nEstimatedChargingTime,172800);		// Max. 48 Stunden sollen dargestellt werden
	
	
	// Antworten auf den Kommunikationstest und des Ladetests
	stMqtt_HAWinoValues.Output.bCheckCurrentDetected := stMqtt_HAWino_In.bCheckCurrentDetected;
	stMqtt_HAWinoValues.Output.bComCheckAnswer := stMqtt_HAWino_In.bComCheckAnswer;
	
	
			
	
	
	
	
	//
	// Setting the parameters for establishing the connection to the Mqtt Broker and initializing the connection.
	//
	IF bSetParameter THEN
		fbIotMqttClient.sHostName := '192.168.0.11';	// IP-Adresse des Servers
		fbIotMqttClient.nHostPort := 1883;
		//fbIotMqttClient.sClientId := ClientId;
		fbIotMqttClient.sClientId := CONCAT('Robot_', INT_TO_STRING(.Var_HAWIno.Robot_Number));
		fbIotMqttClient.sTopicPrefix := '';
		//fbIotMqttClient.nKeepAlive:= 60; 
		fbIotMqttClient.sUserName:= 'VPJ';
		fbIotMqttClient.sUserPassword:= 'R462';
		//fbIotMqttClient.stWill:= ; 
		//fbIotMqttClient.stTLS:= ;
		fbIotMqttClient.ipMessageQueue := fbMessageQueue;
	
		bSetParameter := FALSE;
	END_IF
	
	
	//
	// This method -> MUST BE CALLED CYCLICALLY <- to ensure background communication with the MQTT broker.
	//
	fbIotMqttClient.Execute(bConnect);
	
	IF fbIotMqttClient.bError THEN
		// ToDo: add error logging here
		hrErrorOccurred := fbIotMqttClient.hrErrorCode;
	END_IF
	
		
	IF fbIotMqttClient.bConnected THEN		// Kontrolle, ob der Broker verbunden ist
		IF NOT bSubscribed THEN
			//
			// Abbonieren der Toopics, welche vom PowerMgmt kommen
			//
			bSubscribed := fbIotMqttClient.Subscribe(sTopic:=sTopicSubToPowerMgmt, eQoS:=TcIotMqttQos.AtMostOnceDelivery);
			IF fbIotMqttClient.bError THEN
				// ToDo: add my error logging here
				hrErrorOccurred := fbIotMqttClient.hrErrorCode;
			END_IF
			
			//
			// Abbonieren der Toopics, welche vom Gewerk 1 kommen
			//
			
			//bSubscribed := fbIotMqttClient.Subscribe(sTopic:=sTopicSubToFleetMgmt, eQoS:=TcIotMqttQos.AtMostOnceDelivery);
			//IF fbIotMqttClient.bError THEN
				// ToDo: add my error logging here
			//	hrErrorOccurred := fbIotMqttClient.hrErrorCode;
			//END_IF
			
		END_IF
		
		// Subscribe to Trajectory-Topic if not already connected
		IF NOT bSubcribedTrajectory THEN
			bSubcribedTrajectory := fbIotMqttClient.Subscribe(sTopic:=sTopicSubTrajectory, eQoS:=TcIotMqttQos.AtMostOnceDelivery);
		END_IF
	END_IF	
	
	
	
	// Senden der MQTT- Nachrichten
	
	
	IF fbIotMqttClient.bConnected THEN			// Kontrolle, ob Broker verbunden ist
		fbTimerPub(IN:=TRUE);
		
		//
		// publish new paylod every 500 MS
		//
		IF fbTimerPub.Q THEN					// Abwarten des oben eingestellten Intervalls
			fbTimerPub(IN:=FALSE);
			
			//
			// Nachricht an PowerMgmt
			//
			fbJson.ResetDocument();
			fbJsonDataType.AddJsonValueFromSymbol(fbJson, 'ST_PwrMgmt_HAWino_In', SIZEOF(stMqtt_HAWinoValues.Output), ADR(stMqtt_HAWinoValues.Output));
			//sJsonDoc := fbJson.GetDocument();
			fbJson.CopyDocument(sJsonDoc, SIZEOF(sJsonDoc));
			
			sPayloadPub := sJsonDoc;	
			fbIotMqttClient.Publish(sTopic:= sTopicPubToPowerMgmt, 
										pPayload:= ADR(sPayloadPub), 
										nPayloadSize:= LEN2(ADR(sPayloadPub))+1, 										
										eQoS:= TcIotMqttQos.AtMostOnceDelivery, 
										bRetain:= FALSE, 
										bQueue:= FALSE);
									
			
			SOC_Out	:= CONCAT( '{"SoC" : ',LREAL_TO_STRING(stMqtt_HAWinoValues.Output.fSoC));
			SOC_Out	:= CONCAT( SOC_Out,'}');
			
			
			
			
			//SOC_Out := 	LREAL_TO_STRING(stMqtt_HAWinoValues.Output.fSoC);
			
						
			fbIotMqttClient.Publish(sTopic:= sTopicPubToPowerMgmt_SOC, 
										pPayload:=ADR(SOC_Out), 
										nPayloadSize:= INT_TO_UDINT(LEN(SOC_Out)),
										eQoS:= TcIotMqttQos.AtMostOnceDelivery, 
										bRetain:= FALSE, 
										bQueue:= FALSE);
										
										
			IF fbIotMqttClient.bError THEN
				// ToDo: add error logging here
				hrErrorOccurred := fbIotMqttClient.hrErrorCode;
			END_IF	
			
			//
			// ...
			//	
		END_IF
		
		//publish new Waypointlist, if GW set Flag
		IF inNewWpl THEN
			// TODO WPL array in json umwandeln zum versenden
			
			//Convert WPL Array of type RobotPoseSimple to 3 seperate arrays
			RPSARRAY2XYTARRAY(RobPosSimArr:=TESTWPL,
								x=>xWPL,
								y=>yWPL,
								theta=>thetaWPL);
								
			fbJson.ResetDocument();
			jsonDoc := fbJsonParser.NewDocument();
			jsonDoc := fbJsonParser.AddJsonMember(jsonDoc, '
	(*		fbJson.StartObject(); // entspricht { in Json File
			
			// Add xWPL Array to JSON Document
			fbJson.AddKey('x');
			fbJson.AddString('[');
			FOR cnt:=0 TO 2 DO
				fbJson.AddLreal(xWPL[cnt]);
			END_FOR
			fbJson.AddString(']');
			
			// Add yWPL Array to JSON Document
			fbJson.AddKey('y');
			FOR cnt:=0 TO 2 DO
				fbJson.AddLreal(yWPL[cnt]);
			END_FOR
			
			// Add thetaWPL Array to JSON Document
			fbJson.AddKey('theta');
			FOR cnt:=0 TO 2 DO
				fbJson.AddLreal(thetaWPL[cnt]);
			END_FOR
			
			fbJson.EndObject(); // entspricht } in JSON file
			sJsonDoc := fbJson.GetDocument();
			*)
		//	sPayloadTrajectory :=sJsonDoc;// fbJson.GetDocument();// 
		
	(*		sPayloadTrajectory := '{"x":[';
			FOR cnt:=0 TO 2 DO
				sPayloadTrajectory := CONCAT(sPayloadTrajectory, LREAL_TO_STRING(xWPL[cnt]));
				sPayloadTrajectory := CONCAT(sPayloadTrajectory, ',');
			END_FOR
			sPayloadTrajectory := CONCAT(sPayloadTrajectory, ']');
			
			sPayloadTrajectory := '"y":[';
			FOR cnt:=0 TO 2 DO
				sPayloadTrajectory := CONCAT(sPayloadTrajectory, LREAL_TO_STRING(yWPL[cnt]));
				sPayloadTrajectory := CONCAT(sPayloadTrajectory, ',');
			END_FOR
			sPayloadTrajectory := CONCAT(sPayloadTrajectory, ']');	

			sPayloadTrajectory := '"theta":[';
			FOR cnt:=0 TO 2 DO
				sPayloadTrajectory := CONCAT(sPayloadTrajectory, LREAL_TO_STRING(thetaWPL[cnt]));
				sPayloadTrajectory := CONCAT(sPayloadTrajectory, ',');
			END_FOR
			sPayloadTrajectory := CONCAT(sPayloadTrajectory, ']}');		*)
			// -------------
			// hardcoded test
			//sPayloadTrajectory := TO_STRING(TESTWPL);
			fbIotMqttClient.Publish(sTopic:= sTopicPubWaypointlist, 
										pPayload:= ADR(sPayloadTrajectory), 
										nPayloadSize:= LEN2(ADR(sPayloadTrajectory))+1, 										
										eQoS:= TcIotMqttQos.AtMostOnceDelivery, 
										bRetain:= FALSE, 
										bQueue:= FALSE);
		END_IF
	END_IF
	
	
	
	// Verarbeiten der Subscriptions
	
	
	IF fbMessageQueue.nQueuedMessages > 0 THEN			// Kontrolle, ob neue Daten vorliegen
		IF fbMessageQueue.Dequeue(fbMessage:=fbMessage) THEN
			fbMessage.GetTopic(pTopic:=ADR(sTopicRcv), nTopicSize:=SIZEOF(sTopicRcv) );
			fbMessage.GetPayload(pPayload:=ADR(sPayloadRcv), nPayloadSize:=SIZEOF(sPayloadRcv), bSetNullTermination:=FALSE);
				
			//
			// Message from PowerMgmt
			//
			IF fbMessage.CompareTopic(sTopic:=sTopicSubToPowerMgmt) THEN		// Wenn die Daten vom PowerMgmt kommen, dann führe folgenede Aktion aus
				
			// Json-String aufteilen und in Variablen schreiben
				fbJsonDataType.SetSymbolFromJson(sPayloadRcv,'ST_PwrMgmt_HAWino_Out',SIZEOF(stMqtt_HAWinoValues.Input),ADR(stMqtt_HAWinoValues.Input));
			END_IF
		
			//
			// Message from Trajectory Generator
			//
			IF fbMessage.CompareTopic(sTopic:=sTopicSubTrajectory) THEN
				fbJsonDataType.SetSymbolFromJson(sPayloadRcv,'RobotPoseSimple',SIZEOF(TESTTRAJECTORY),ADR(TESTTRAJECTORY));
			END_IF
			//
			// Hier werden weitere Topics verarbeitet
			//
			
		END_IF
	END_IF		
	
	
	
	
	// Evaulierung der empfangenen Daten
	
	//
	// ToDo: Plausibilitätsprüfung von stMqtt_HAWinoValues.Input und evt. TypConversion
	// Attention! The assignment of input to output is correct. Don `t change!
	//	
	
	stMqtt_HAWino_Out.bChargingActive := stMqtt_HAWinoValues.Input.bChargingActive;
	stMqtt_HAWino_Out.bExternalRecalibrationTrigger := stMqtt_HAWinoValues.Input.bExternalRecalibrationTrigger;
	stMqtt_HAWino_Out.fExternalRecalibrationValue := stMqtt_HAWinoValues.Input.fExternalRecalibrationValue;
	
	
	// Hier Communication Check einbauen
	
	//fbComCheckFlag(Set:= stMqtt_HAWinoValues.Input.bComCheckRequest, 
	//					Reset1:= NOT stMqtt_HAWinoValues.Input.bComCheckRequest,
	//					Q1 => bComCheckAnswer);
	bComCheckAnswer	:= TRUE;
					
END_IF]]></ST>
    </Implementation>
    <LineIds Name="MQTT">
      <LineId Id="1287" Count="172" />
      <LineId Id="1532" Count="2" />
      <LineId Id="1460" Count="1" />
      <LineId Id="1604" Count="0" />
      <LineId Id="1606" Count="0" />
      <LineId Id="1556" Count="0" />
      <LineId Id="1565" Count="0" />
      <LineId Id="1542" Count="0" />
      <LineId Id="1535" Count="0" />
      <LineId Id="1560" Count="0" />
      <LineId Id="1540" Count="0" />
      <LineId Id="1536" Count="0" />
      <LineId Id="1541" Count="0" />
      <LineId Id="1561" Count="0" />
      <LineId Id="1548" Count="0" />
      <LineId Id="1547" Count="0" />
      <LineId Id="1544" Count="2" />
      <LineId Id="1543" Count="0" />
      <LineId Id="1549" Count="4" />
      <LineId Id="1462" Count="0" />
      <LineId Id="1557" Count="2" />
      <LineId Id="1464" Count="1" />
      <LineId Id="1567" Count="0" />
      <LineId Id="1569" Count="0" />
      <LineId Id="1571" Count="1" />
      <LineId Id="1586" Count="0" />
      <LineId Id="1573" Count="2" />
      <LineId Id="1592" Count="4" />
      <LineId Id="1587" Count="0" />
      <LineId Id="1598" Count="5" />
      <LineId Id="1597" Count="0" />
      <LineId Id="1466" Count="65" />
      <LineId Id="438" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>